<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>client/lib/angular-bootstrap/ui-bootstrap-tpls.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/classroom.html">classroom</a></li>
                                <li><a href="../classes/classroom.attendance.html">classroom.attendance</a></li>
                                <li><a href="../classes/classroom.AttendanceService.html">classroom.AttendanceService</a></li>
                                <li><a href="../classes/classroom.AuthFactory.html">classroom.AuthFactory</a></li>
                                <li><a href="../classes/classroom.grades.html">classroom.grades</a></li>
                                <li><a href="../classes/classroom.GradeService.html">classroom.GradeService</a></li>
                                <li><a href="../classes/classroom.LessonService.html">classroom.LessonService</a></li>
                                <li><a href="../classes/classroom.login.html">classroom.login</a></li>
                                <li><a href="../classes/classroom.signup.html">classroom.signup</a></li>
                                <li><a href="../classes/classroom.syllabus.html">classroom.syllabus</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/ng.html">ng</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: client/lib/angular-bootstrap/ui-bootstrap-tpls.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 0.13.0 - 2015-05-02
 * License: MIT
 */
angular.module(&quot;ui.bootstrap&quot;, [&quot;ui.bootstrap.tpls&quot;, &quot;ui.bootstrap.collapse&quot;,&quot;ui.bootstrap.accordion&quot;,&quot;ui.bootstrap.alert&quot;,&quot;ui.bootstrap.bindHtml&quot;,&quot;ui.bootstrap.buttons&quot;,&quot;ui.bootstrap.carousel&quot;,&quot;ui.bootstrap.dateparser&quot;,&quot;ui.bootstrap.position&quot;,&quot;ui.bootstrap.datepicker&quot;,&quot;ui.bootstrap.dropdown&quot;,&quot;ui.bootstrap.modal&quot;,&quot;ui.bootstrap.pagination&quot;,&quot;ui.bootstrap.tooltip&quot;,&quot;ui.bootstrap.popover&quot;,&quot;ui.bootstrap.progressbar&quot;,&quot;ui.bootstrap.rating&quot;,&quot;ui.bootstrap.tabs&quot;,&quot;ui.bootstrap.timepicker&quot;,&quot;ui.bootstrap.transition&quot;,&quot;ui.bootstrap.typeahead&quot;]);
angular.module(&quot;ui.bootstrap.tpls&quot;, [&quot;template/accordion/accordion-group.html&quot;,&quot;template/accordion/accordion.html&quot;,&quot;template/alert/alert.html&quot;,&quot;template/carousel/carousel.html&quot;,&quot;template/carousel/slide.html&quot;,&quot;template/datepicker/datepicker.html&quot;,&quot;template/datepicker/day.html&quot;,&quot;template/datepicker/month.html&quot;,&quot;template/datepicker/popup.html&quot;,&quot;template/datepicker/year.html&quot;,&quot;template/modal/backdrop.html&quot;,&quot;template/modal/window.html&quot;,&quot;template/pagination/pager.html&quot;,&quot;template/pagination/pagination.html&quot;,&quot;template/tooltip/tooltip-html-popup.html&quot;,&quot;template/tooltip/tooltip-html-unsafe-popup.html&quot;,&quot;template/tooltip/tooltip-popup.html&quot;,&quot;template/tooltip/tooltip-template-popup.html&quot;,&quot;template/popover/popover-template.html&quot;,&quot;template/popover/popover.html&quot;,&quot;template/progressbar/bar.html&quot;,&quot;template/progressbar/progress.html&quot;,&quot;template/progressbar/progressbar.html&quot;,&quot;template/rating/rating.html&quot;,&quot;template/tabs/tab.html&quot;,&quot;template/tabs/tabset.html&quot;,&quot;template/timepicker/timepicker.html&quot;,&quot;template/typeahead/typeahead-match.html&quot;,&quot;template/typeahead/typeahead-popup.html&quot;]);
angular.module(&#x27;ui.bootstrap.collapse&#x27;, [])

  .directive(&#x27;collapse&#x27;, [&#x27;$animate&#x27;, function ($animate) {

    return {
      link: function (scope, element, attrs) {
        function expand() {
          element.removeClass(&#x27;collapse&#x27;).addClass(&#x27;collapsing&#x27;);
          $animate.addClass(element, &#x27;in&#x27;, {
            to: { height: element[0].scrollHeight + &#x27;px&#x27; }
          }).then(expandDone);
        }

        function expandDone() {
          element.removeClass(&#x27;collapsing&#x27;);
          element.css({height: &#x27;auto&#x27;});
        }

        function collapse() {
          element
            // IMPORTANT: The height must be set before adding &quot;collapsing&quot; class.
            // Otherwise, the browser attempts to animate from height 0 (in
            // collapsing class) to the given height here.
            .css({height: element[0].scrollHeight + &#x27;px&#x27;})
            // initially all panel collapse have the collapse class, this removal
            // prevents the animation from jumping to collapsed state
            .removeClass(&#x27;collapse&#x27;)
            .addClass(&#x27;collapsing&#x27;);

          $animate.removeClass(element, &#x27;in&#x27;, {
            to: {height: &#x27;0&#x27;}
          }).then(collapseDone);
        }

        function collapseDone() {
          element.css({height: &#x27;0&#x27;}); // Required so that collapse works when animation is disabled
          element.removeClass(&#x27;collapsing&#x27;);
          element.addClass(&#x27;collapse&#x27;);
        }

        scope.$watch(attrs.collapse, function (shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);

angular.module(&#x27;ui.bootstrap.accordion&#x27;, [&#x27;ui.bootstrap.collapse&#x27;])

.constant(&#x27;accordionConfig&#x27;, {
  closeOthers: true
})

.controller(&#x27;AccordionController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;accordionConfig&#x27;, function ($scope, $attrs, accordionConfig) {

  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if ( closeOthers ) {
      angular.forEach(this.groups, function (group) {
        if ( group !== openGroup ) {
          group.isOpen = false;
        }
      });
    }
  };

  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on(&#x27;$destroy&#x27;, function (event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if ( index !== -1 ) {
      this.groups.splice(index, 1);
    }
  };

}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive(&#x27;accordion&#x27;, function () {
  return {
    restrict:&#x27;EA&#x27;,
    controller:&#x27;AccordionController&#x27;,
    transclude: true,
    replace: false,
    templateUrl: &#x27;template/accordion/accordion.html&#x27;
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive(&#x27;accordionGroup&#x27;, function() {
  return {
    require:&#x27;^accordion&#x27;,         // We need this directive to be inside an accordion
    restrict:&#x27;EA&#x27;,
    transclude:true,              // It transcludes the contents of the directive into the template
    replace: true,                // The element containing the directive will be replaced with the template
    templateUrl:&#x27;template/accordion/accordion-group.html&#x27;,
    scope: {
      heading: &#x27;@&#x27;,               // Interpolate the heading attribute onto this scope
      isOpen: &#x27;=?&#x27;,
      isDisabled: &#x27;=?&#x27;
    },
    controller: function() {
      this.setHeading = function(element) {
        this.heading = element;
      };
    },
    link: function(scope, element, attrs, accordionCtrl) {
      accordionCtrl.addGroup(scope);

      scope.$watch(&#x27;isOpen&#x27;, function(value) {
        if ( value ) {
          accordionCtrl.closeOthers(scope);
        }
      });

      scope.toggleOpen = function() {
        if ( !scope.isDisabled ) {
          scope.isOpen = !scope.isOpen;
        }
      };
    }
  };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
// &lt;accordion-group&gt;
//   &lt;accordion-heading&gt;Heading containing HTML - &lt;img src=&quot;...&quot;&gt;&lt;/accordion-heading&gt;
// &lt;/accordion-group&gt;
.directive(&#x27;accordionHeading&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    transclude: true,   // Grab the contents to be used as the heading
    template: &#x27;&#x27;,       // In effect remove this element!
    replace: true,
    require: &#x27;^accordionGroup&#x27;,
    link: function(scope, element, attr, accordionGroupCtrl, transclude) {
      // Pass the heading to the accordion-group controller
      // so that it can be transcluded into the right place in the template
      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
// &lt;div class=&quot;accordion-group&quot;&gt;
//   &lt;div class=&quot;accordion-heading&quot; &gt;&lt;a ... accordion-transclude=&quot;heading&quot;&gt;...&lt;/a&gt;&lt;/div&gt;
//   ...
// &lt;/div&gt;
.directive(&#x27;accordionTransclude&#x27;, function() {
  return {
    require: &#x27;^accordionGroup&#x27;,
    link: function(scope, element, attr, controller) {
      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
        if ( heading ) {
          element.html(&#x27;&#x27;);
          element.append(heading);
        }
      });
    }
  };
})

;

angular.module(&#x27;ui.bootstrap.alert&#x27;, [])

.controller(&#x27;AlertController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, function ($scope, $attrs) {
  $scope.closeable = &#x27;close&#x27; in $attrs;
  this.close = $scope.close;
}])

.directive(&#x27;alert&#x27;, function () {
  return {
    restrict:&#x27;EA&#x27;,
    controller:&#x27;AlertController&#x27;,
    templateUrl:&#x27;template/alert/alert.html&#x27;,
    transclude:true,
    replace:true,
    scope: {
      type: &#x27;@&#x27;,
      close: &#x27;&amp;&#x27;
    }
  };
})

.directive(&#x27;dismissOnTimeout&#x27;, [&#x27;$timeout&#x27;, function($timeout) {
  return {
    require: &#x27;alert&#x27;,
    link: function(scope, element, attrs, alertCtrl) {
      $timeout(function(){
        alertCtrl.close();
      }, parseInt(attrs.dismissOnTimeout, 10));
    }
  };
}]);

angular.module(&#x27;ui.bootstrap.bindHtml&#x27;, [])

  .directive(&#x27;bindHtmlUnsafe&#x27;, function () {
    return function (scope, element, attr) {
      element.addClass(&#x27;ng-binding&#x27;).data(&#x27;$binding&#x27;, attr.bindHtmlUnsafe);
      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
        element.html(value || &#x27;&#x27;);
      });
    };
  });
angular.module(&#x27;ui.bootstrap.buttons&#x27;, [])

.constant(&#x27;buttonConfig&#x27;, {
  activeClass: &#x27;active&#x27;,
  toggleEvent: &#x27;click&#x27;
})

.controller(&#x27;ButtonsController&#x27;, [&#x27;buttonConfig&#x27;, function(buttonConfig) {
  this.activeClass = buttonConfig.activeClass || &#x27;active&#x27;;
  this.toggleEvent = buttonConfig.toggleEvent || &#x27;click&#x27;;
}])

.directive(&#x27;btnRadio&#x27;, function () {
  return {
    require: [&#x27;btnRadio&#x27;, &#x27;ngModel&#x27;],
    controller: &#x27;ButtonsController&#x27;,
    link: function (scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      //model -&gt; UI
      ngModelCtrl.$render = function () {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
      };

      //ui-&gt;model
      element.bind(buttonsCtrl.toggleEvent, function () {
        var isActive = element.hasClass(buttonsCtrl.activeClass);

        if (!isActive || angular.isDefined(attrs.uncheckable)) {
          scope.$apply(function () {
            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
            ngModelCtrl.$render();
          });
        }
      });
    }
  };
})

.directive(&#x27;btnCheckbox&#x27;, function () {
  return {
    require: [&#x27;btnCheckbox&#x27;, &#x27;ngModel&#x27;],
    controller: &#x27;ButtonsController&#x27;,
    link: function (scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      function getTrueValue() {
        return getCheckboxValue(attrs.btnCheckboxTrue, true);
      }

      function getFalseValue() {
        return getCheckboxValue(attrs.btnCheckboxFalse, false);
      }

      function getCheckboxValue(attributeValue, defaultValue) {
        var val = scope.$eval(attributeValue);
        return angular.isDefined(val) ? val : defaultValue;
      }

      //model -&gt; UI
      ngModelCtrl.$render = function () {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui-&gt;model
      element.bind(buttonsCtrl.toggleEvent, function () {
        scope.$apply(function () {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
});

/**
* @ngdoc overview
* @name ui.bootstrap.carousel
*
* @description
* AngularJS version of an image carousel.
*
*/
angular.module(&#x27;ui.bootstrap.carousel&#x27;, [])
.controller(&#x27;CarouselController&#x27;, [&#x27;$scope&#x27;, &#x27;$interval&#x27;, &#x27;$animate&#x27;, function ($scope, $interval, $animate) {
  var self = this,
    slides = self.slides = $scope.slides = [],
    currentIndex = -1,
    currentInterval, isPlaying;
  self.currentSlide = null;

  var destroyed = false;
  /* direction: &quot;prev&quot; or &quot;next&quot; */
  self.select = $scope.select = function(nextSlide, direction) {
    var nextIndex = self.indexOfSlide(nextSlide);
    //Decide direction if it&#x27;s not given
    if (direction === undefined) {
      direction = nextIndex &gt; self.getCurrentIndex() ? &#x27;next&#x27; : &#x27;prev&#x27;;
    }
    if (nextSlide &amp;&amp; nextSlide !== self.currentSlide) {
      goNext();
    }
    function goNext() {
      // Scope has been destroyed, stop here.
      if (destroyed) { return; }

      angular.extend(nextSlide, {direction: direction, active: true});
      angular.extend(self.currentSlide || {}, {direction: direction, active: false});
      if ($animate.enabled() &amp;&amp; !$scope.noTransition &amp;&amp; nextSlide.$element) {
        $scope.$currentTransition = true;
        nextSlide.$element.one(&#x27;$animate:close&#x27;, function closeFn() {
          $scope.$currentTransition = null;
        });
      }

      self.currentSlide = nextSlide;
      currentIndex = nextIndex;
      //every time you change slides, reset the timer
      restartTimer();
    }
  };
  $scope.$on(&#x27;$destroy&#x27;, function () {
    destroyed = true;
  });

  function getSlideByIndex(index) {
    if (angular.isUndefined(slides[index].index)) {
      return slides[index];
    }
    var i, len = slides.length;
    for (i = 0; i &lt; slides.length; ++i) {
      if (slides[i].index == index) {
        return slides[i];
      }
    }
  }

  self.getCurrentIndex = function() {
    if (self.currentSlide &amp;&amp; angular.isDefined(self.currentSlide.index)) {
      return +self.currentSlide.index;
    }
    return currentIndex;
  };

  /* Allow outside people to call indexOf on slides array */
  self.indexOfSlide = function(slide) {
    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
  };

  $scope.next = function() {
    var newIndex = (self.getCurrentIndex() + 1) % slides.length;

    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (!$scope.$currentTransition) {
      return self.select(getSlideByIndex(newIndex), &#x27;next&#x27;);
    }
  };

  $scope.prev = function() {
    var newIndex = self.getCurrentIndex() - 1 &lt; 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (!$scope.$currentTransition) {
      return self.select(getSlideByIndex(newIndex), &#x27;prev&#x27;);
    }
  };

  $scope.isActive = function(slide) {
     return self.currentSlide === slide;
  };

  $scope.$watch(&#x27;interval&#x27;, restartTimer);
  $scope.$on(&#x27;$destroy&#x27;, resetTimer);

  function restartTimer() {
    resetTimer();
    var interval = +$scope.interval;
    if (!isNaN(interval) &amp;&amp; interval &gt; 0) {
      currentInterval = $interval(timerFn, interval);
    }
  }

  function resetTimer() {
    if (currentInterval) {
      $interval.cancel(currentInterval);
      currentInterval = null;
    }
  }

  function timerFn() {
    var interval = +$scope.interval;
    if (isPlaying &amp;&amp; !isNaN(interval) &amp;&amp; interval &gt; 0) {
      $scope.next();
    } else {
      $scope.pause();
    }
  }

  $scope.play = function() {
    if (!isPlaying) {
      isPlaying = true;
      restartTimer();
    }
  };
  $scope.pause = function() {
    if (!$scope.noPause) {
      isPlaying = false;
      resetTimer();
    }
  };

  self.addSlide = function(slide, element) {
    slide.$element = element;
    slides.push(slide);
    //if this is the first slide or the slide is set to active, select it
    if(slides.length === 1 || slide.active) {
      self.select(slides[slides.length-1]);
      if (slides.length == 1) {
        $scope.play();
      }
    } else {
      slide.active = false;
    }
  };

  self.removeSlide = function(slide) {
    if (angular.isDefined(slide.index)) {
      slides.sort(function(a, b) {
        return +a.index &gt; +b.index;
      });
    }
    //get the index of the slide inside the carousel
    var index = slides.indexOf(slide);
    slides.splice(index, 1);
    if (slides.length &gt; 0 &amp;&amp; slide.active) {
      if (index &gt;= slides.length) {
        self.select(slides[index-1]);
      } else {
        self.select(slides[index]);
      }
    } else if (currentIndex &gt; index) {
      currentIndex--;
    }
  };

}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:carousel
 * @restrict EA
 *
 * @description
 * Carousel is the outer container for a set of image &#x27;slides&#x27; to showcase.
 *
 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
 *
 * @example
&lt;example module=&quot;ui.bootstrap&quot;&gt;
  &lt;file name=&quot;index.html&quot;&gt;
    &lt;carousel&gt;
      &lt;slide&gt;
        &lt;img src=&quot;http://placekitten.com/150/150&quot; style=&quot;margin:auto;&quot;&gt;
        &lt;div class=&quot;carousel-caption&quot;&gt;
          &lt;p&gt;Beautiful!&lt;/p&gt;
        &lt;/div&gt;
      &lt;/slide&gt;
      &lt;slide&gt;
        &lt;img src=&quot;http://placekitten.com/100/150&quot; style=&quot;margin:auto;&quot;&gt;
        &lt;div class=&quot;carousel-caption&quot;&gt;
          &lt;p&gt;D&#x27;aww!&lt;/p&gt;
        &lt;/div&gt;
      &lt;/slide&gt;
    &lt;/carousel&gt;
  &lt;/file&gt;
  &lt;file name=&quot;demo.css&quot;&gt;
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  &lt;/file&gt;
&lt;/example&gt;
 */
.directive(&#x27;carousel&#x27;, [function() {
  return {
    restrict: &#x27;EA&#x27;,
    transclude: true,
    replace: true,
    controller: &#x27;CarouselController&#x27;,
    require: &#x27;carousel&#x27;,
    templateUrl: &#x27;template/carousel/carousel.html&#x27;,
    scope: {
      interval: &#x27;=&#x27;,
      noTransition: &#x27;=&#x27;,
      noPause: &#x27;=&#x27;
    }
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:slide
 * @restrict EA
 *
 * @description
 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
 *
 * @param {boolean=} active Model binding, whether or not this slide is currently active.
 * @param {number=} index The index of the slide. The slides will be sorted by this parameter.
 *
 * @example
&lt;example module=&quot;ui.bootstrap&quot;&gt;
  &lt;file name=&quot;index.html&quot;&gt;
&lt;div ng-controller=&quot;CarouselDemoCtrl&quot;&gt;
  &lt;carousel&gt;
    &lt;slide ng-repeat=&quot;slide in slides&quot; active=&quot;slide.active&quot; index=&quot;$index&quot;&gt;
      &lt;img ng-src=&quot;{{slide.image}}&quot; style=&quot;margin:auto;&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
        &lt;h4&gt;Slide {{$index}}&lt;/h4&gt;
        &lt;p&gt;{{slide.text}}&lt;/p&gt;
      &lt;/div&gt;
    &lt;/slide&gt;
  &lt;/carousel&gt;
  Interval, in milliseconds: &lt;input type=&quot;number&quot; ng-model=&quot;myInterval&quot;&gt;
  &lt;br /&gt;Enter a negative number to stop the interval.
&lt;/div&gt;
  &lt;/file&gt;
  &lt;file name=&quot;script.js&quot;&gt;
function CarouselDemoCtrl($scope) {
  $scope.myInterval = 5000;
}
  &lt;/file&gt;
  &lt;file name=&quot;demo.css&quot;&gt;
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  &lt;/file&gt;
&lt;/example&gt;
*/

.directive(&#x27;slide&#x27;, function() {
  return {
    require: &#x27;^carousel&#x27;,
    restrict: &#x27;EA&#x27;,
    transclude: true,
    replace: true,
    templateUrl: &#x27;template/carousel/slide.html&#x27;,
    scope: {
      active: &#x27;=?&#x27;,
      index: &#x27;=?&#x27;
    },
    link: function (scope, element, attrs, carouselCtrl) {
      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on(&#x27;$destroy&#x27;, function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch(&#x27;active&#x27;, function(active) {
        if (active) {
          carouselCtrl.select(scope);
        }
      });
    }
  };
})

.animation(&#x27;.item&#x27;, [
         &#x27;$animate&#x27;,
function ($animate) {
  return {
    beforeAddClass: function (element, className, done) {
      // Due to transclusion, noTransition property is on parent&#x27;s scope
      if (className == &#x27;active&#x27; &amp;&amp; element.parent() &amp;&amp;
          !element.parent().scope().noTransition) {
        var stopped = false;
        var direction = element.isolateScope().direction;
        var directionClass = direction == &#x27;next&#x27; ? &#x27;left&#x27; : &#x27;right&#x27;;
        element.addClass(direction);
        $animate.addClass(element, directionClass).then(function () {
          if (!stopped) {
            element.removeClass(directionClass + &#x27; &#x27; + direction);
          }
          done();
        });

        return function () {
          stopped = true;
        };
      }
      done();
    },
    beforeRemoveClass: function (element, className, done) {
      // Due to transclusion, noTransition property is on parent&#x27;s scope
      if (className == &#x27;active&#x27; &amp;&amp; element.parent() &amp;&amp;
          !element.parent().scope().noTransition) {
        var stopped = false;
        var direction = element.isolateScope().direction;
        var directionClass = direction == &#x27;next&#x27; ? &#x27;left&#x27; : &#x27;right&#x27;;
        $animate.addClass(element, directionClass).then(function () {
          if (!stopped) {
            element.removeClass(directionClass);
          }
          done();
        });
        return function () {
          stopped = true;
        };
      }
      done();
    }
  };

}])


;

angular.module(&#x27;ui.bootstrap.dateparser&#x27;, [])

.service(&#x27;dateParser&#x27;, [&#x27;$locale&#x27;, &#x27;orderByFilter&#x27;, function($locale, orderByFilter) {
  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  this.parsers = {};

  var formatCodeToRegex = {
    &#x27;yyyy&#x27;: {
      regex: &#x27;\\d{4}&#x27;,
      apply: function(value) { this.year = +value; }
    },
    &#x27;yy&#x27;: {
      regex: &#x27;\\d{2}&#x27;,
      apply: function(value) { this.year = +value + 2000; }
    },
    &#x27;y&#x27;: {
      regex: &#x27;\\d{1,4}&#x27;,
      apply: function(value) { this.year = +value; }
    },
    &#x27;MMMM&#x27;: {
      regex: $locale.DATETIME_FORMATS.MONTH.join(&#x27;|&#x27;),
      apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }
    },
    &#x27;MMM&#x27;: {
      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join(&#x27;|&#x27;),
      apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }
    },
    &#x27;MM&#x27;: {
      regex: &#x27;0[1-9]|1[0-2]&#x27;,
      apply: function(value) { this.month = value - 1; }
    },
    &#x27;M&#x27;: {
      regex: &#x27;[1-9]|1[0-2]&#x27;,
      apply: function(value) { this.month = value - 1; }
    },
    &#x27;dd&#x27;: {
      regex: &#x27;[0-2][0-9]{1}|3[0-1]{1}&#x27;,
      apply: function(value) { this.date = +value; }
    },
    &#x27;d&#x27;: {
      regex: &#x27;[1-2]?[0-9]{1}|3[0-1]{1}&#x27;,
      apply: function(value) { this.date = +value; }
    },
    &#x27;EEEE&#x27;: {
      regex: $locale.DATETIME_FORMATS.DAY.join(&#x27;|&#x27;)
    },
    &#x27;EEE&#x27;: {
      regex: $locale.DATETIME_FORMATS.SHORTDAY.join(&#x27;|&#x27;)
    },
    &#x27;HH&#x27;: {
      regex: &#x27;(?:0|1)[0-9]|2[0-3]&#x27;,
      apply: function(value) { this.hours = +value; }
    },
    &#x27;H&#x27;: {
      regex: &#x27;1?[0-9]|2[0-3]&#x27;,
      apply: function(value) { this.hours = +value; }
    },
    &#x27;mm&#x27;: {
      regex: &#x27;[0-5][0-9]&#x27;,
      apply: function(value) { this.minutes = +value; }
    },
    &#x27;m&#x27;: {
      regex: &#x27;[0-9]|[1-5][0-9]&#x27;,
      apply: function(value) { this.minutes = +value; }
    },
    &#x27;sss&#x27;: {
      regex: &#x27;[0-9][0-9][0-9]&#x27;,
      apply: function(value) { this.milliseconds = +value; }
    },
    &#x27;ss&#x27;: {
      regex: &#x27;[0-5][0-9]&#x27;,
      apply: function(value) { this.seconds = +value; }
    },
    &#x27;s&#x27;: {
      regex: &#x27;[0-9]|[1-5][0-9]&#x27;,
      apply: function(value) { this.seconds = +value; }
    }
  };

  function createParser(format) {
    var map = [], regex = format.split(&#x27;&#x27;);

    angular.forEach(formatCodeToRegex, function(data, code) {
      var index = format.indexOf(code);

      if (index &gt; -1) {
        format = format.split(&#x27;&#x27;);

        regex[index] = &#x27;(&#x27; + data.regex + &#x27;)&#x27;;
        format[index] = &#x27;$&#x27;; // Custom symbol to define consumed part of format
        for (var i = index + 1, n = index + code.length; i &lt; n; i++) {
          regex[i] = &#x27;&#x27;;
          format[i] = &#x27;$&#x27;;
        }
        format = format.join(&#x27;&#x27;);

        map.push({ index: index, apply: data.apply });
      }
    });

    return {
      regex: new RegExp(&#x27;^&#x27; + regex.join(&#x27;&#x27;) + &#x27;$&#x27;),
      map: orderByFilter(map, &#x27;index&#x27;)
    };
  }

  this.parse = function(input, format, baseDate) {
    if ( !angular.isString(input) || !format ) {
      return input;
    }

    format = $locale.DATETIME_FORMATS[format] || format;
    format = format.replace(SPECIAL_CHARACTERS_REGEXP, &#x27;\\$&amp;&#x27;);

    if ( !this.parsers[format] ) {
      this.parsers[format] = createParser(format);
    }

    var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex);

    if ( results &amp;&amp; results.length ) {
      var fields, dt;
      if (baseDate) {
        fields = {
          year: baseDate.getFullYear(),
          month: baseDate.getMonth(),
          date: baseDate.getDate(),
          hours: baseDate.getHours(),
          minutes: baseDate.getMinutes(),
          seconds: baseDate.getSeconds(),
          milliseconds: baseDate.getMilliseconds()
        };
      } else {
        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
      }

      for( var i = 1, n = results.length; i &lt; n; i++ ) {
        var mapper = map[i-1];
        if ( mapper.apply ) {
          mapper.apply.call(fields, results[i]);
        }
      }

      if ( isValid(fields.year, fields.month, fields.date) ) {
        dt = new Date(fields.year, fields.month, fields.date, fields.hours, fields.minutes, fields.seconds,
          fields.milliseconds || 0);
      }

      return dt;
    }
  };

  // Check if date is valid for specific month (and year for February).
  // Month: 0 = Jan, 1 = Feb, etc
  function isValid(year, month, date) {
    if (date &lt; 1) {
      return false;
    }

    if ( month === 1 &amp;&amp; date &gt; 28) {
        return date === 29 &amp;&amp; ((year % 4 === 0 &amp;&amp; year % 100 !== 0) || year % 400 === 0);
    }

    if ( month === 3 || month === 5 || month === 8 || month === 10) {
        return date &lt; 31;
    }

    return true;
  }
}]);

angular.module(&#x27;ui.bootstrap.position&#x27;, [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory(&#x27;$position&#x27;, [&#x27;$document&#x27;, &#x27;$window&#x27;, function ($document, $window) {

    function getStyle(el, cssprop) {
      if (el.currentStyle) { //IE
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      // finally try and get inline style
      return el.style[cssprop];
    }

    /**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
    function isStaticPositioned(element) {
      return (getStyle(element, &#x27;position&#x27;) || &#x27;static&#x27; ) === &#x27;static&#x27;;
    }

    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
    var parentOffsetEl = function (element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent &amp;&amp; offsetParent !== docDomEl &amp;&amp; isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };

    return {
      /**
       * Provides read-only equivalent of jQuery&#x27;s position function:
       * http://api.jquery.com/position/
       */
      position: function (element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = { top: 0, left: 0 };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }

        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop(&#x27;offsetWidth&#x27;),
          height: boundingClientRect.height || element.prop(&#x27;offsetHeight&#x27;),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },

      /**
       * Provides read-only equivalent of jQuery&#x27;s offset function:
       * http://api.jquery.com/offset/
       */
      offset: function (element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop(&#x27;offsetWidth&#x27;),
          height: boundingClientRect.height || element.prop(&#x27;offsetHeight&#x27;),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
        };
      },

      /**
       * Provides coordinates for the targetEl in relation to hostEl
       */
      positionElements: function (hostEl, targetEl, positionStr, appendToBody) {

        var positionStrParts = positionStr.split(&#x27;-&#x27;);
        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || &#x27;center&#x27;;

        var hostElPos,
          targetElWidth,
          targetElHeight,
          targetElPos;

        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);

        targetElWidth = targetEl.prop(&#x27;offsetWidth&#x27;);
        targetElHeight = targetEl.prop(&#x27;offsetHeight&#x27;);

        var shiftWidth = {
          center: function () {
            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
          },
          left: function () {
            return hostElPos.left;
          },
          right: function () {
            return hostElPos.left + hostElPos.width;
          }
        };

        var shiftHeight = {
          center: function () {
            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
          },
          top: function () {
            return hostElPos.top;
          },
          bottom: function () {
            return hostElPos.top + hostElPos.height;
          }
        };

        switch (pos0) {
          case &#x27;right&#x27;:
            targetElPos = {
              top: shiftHeight[pos1](),
              left: shiftWidth[pos0]()
            };
            break;
          case &#x27;left&#x27;:
            targetElPos = {
              top: shiftHeight[pos1](),
              left: hostElPos.left - targetElWidth
            };
            break;
          case &#x27;bottom&#x27;:
            targetElPos = {
              top: shiftHeight[pos0](),
              left: shiftWidth[pos1]()
            };
            break;
          default:
            targetElPos = {
              top: hostElPos.top - targetElHeight,
              left: shiftWidth[pos1]()
            };
            break;
        }

        return targetElPos;
      }
    };
  }]);

angular.module(&#x27;ui.bootstrap.datepicker&#x27;, [&#x27;ui.bootstrap.dateparser&#x27;, &#x27;ui.bootstrap.position&#x27;])

.constant(&#x27;datepickerConfig&#x27;, {
  formatDay: &#x27;dd&#x27;,
  formatMonth: &#x27;MMMM&#x27;,
  formatYear: &#x27;yyyy&#x27;,
  formatDayHeader: &#x27;EEE&#x27;,
  formatDayTitle: &#x27;MMMM yyyy&#x27;,
  formatMonthTitle: &#x27;yyyy&#x27;,
  datepickerMode: &#x27;day&#x27;,
  minMode: &#x27;day&#x27;,
  maxMode: &#x27;year&#x27;,
  showWeeks: true,
  startingDay: 0,
  yearRange: 20,
  minDate: null,
  maxDate: null,
  shortcutPropagation: false
})

.controller(&#x27;DatepickerController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;$parse&#x27;, &#x27;$interpolate&#x27;, &#x27;$timeout&#x27;, &#x27;$log&#x27;, &#x27;dateFilter&#x27;, &#x27;datepickerConfig&#x27;, function($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;

  // Modes chain
  this.modes = [&#x27;day&#x27;, &#x27;month&#x27;, &#x27;year&#x27;];

  // Configuration attributes
  angular.forEach([&#x27;formatDay&#x27;, &#x27;formatMonth&#x27;, &#x27;formatYear&#x27;, &#x27;formatDayHeader&#x27;, &#x27;formatDayTitle&#x27;, &#x27;formatMonthTitle&#x27;,
                   &#x27;minMode&#x27;, &#x27;maxMode&#x27;, &#x27;showWeeks&#x27;, &#x27;startingDay&#x27;, &#x27;yearRange&#x27;, &#x27;shortcutPropagation&#x27;], function( key, index ) {
    self[key] = angular.isDefined($attrs[key]) ? (index &lt; 8 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
  });

  // Watchable date attributes
  angular.forEach([&#x27;minDate&#x27;, &#x27;maxDate&#x27;], function( key ) {
    if ( $attrs[key] ) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = value ? new Date(value) : null;
        self.refreshView();
      });
    } else {
      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }
  });

  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
  $scope.maxMode = self.maxMode;
  $scope.uniqueId = &#x27;datepicker-&#x27; + $scope.$id + &#x27;-&#x27; + Math.floor(Math.random() * 10000);

  if(angular.isDefined($attrs.initDate)) {
    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
    $scope.$parent.$watch($attrs.initDate, function(initDate){
      if(initDate &amp;&amp; (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)){
        self.activeDate = initDate;
        self.refreshView();
      }
    });
  } else {
    this.activeDate =  new Date();
  }

  $scope.isActive = function(dateObject) {
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function( ngModelCtrl_ ) {
    ngModelCtrl = ngModelCtrl_;

    ngModelCtrl.$render = function() {
      self.render();
    };
  };

  this.render = function() {
    if ( ngModelCtrl.$viewValue ) {
      var date = new Date( ngModelCtrl.$viewValue ),
          isValid = !isNaN(date);

      if ( isValid ) {
        this.activeDate = date;
      } else {
        $log.error(&#x27;Datepicker directive: &quot;ng-model&quot; value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.&#x27;);
      }
      ngModelCtrl.$setValidity(&#x27;date&#x27;, isValid);
    }
    this.refreshView();
  };

  this.refreshView = function() {
    if ( this.element ) {
      this._refreshView();

      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
      ngModelCtrl.$setValidity(&#x27;date-disabled&#x27;, !date || (this.element &amp;&amp; !this.isDisabled(date)));
    }
  };

  this.createDateObject = function(date, format) {
    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
    return {
      date: date,
      label: dateFilter(date, format),
      selected: model &amp;&amp; this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      current: this.compare(date, new Date()) === 0,
      customClass: this.customClass(date)
    };
  };

  this.isDisabled = function( date ) {
    return ((this.minDate &amp;&amp; this.compare(date, this.minDate) &lt; 0) || (this.maxDate &amp;&amp; this.compare(date, this.maxDate) &gt; 0) || ($attrs.dateDisabled &amp;&amp; $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
  };

    this.customClass = function( date ) {
      return $scope.customClass({date: date, mode: $scope.datepickerMode});
    };

  // Split array into smaller arrays
  this.split = function(arr, size) {
    var arrays = [];
    while (arr.length &gt; 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  $scope.select = function( date ) {
    if ( $scope.datepickerMode === self.minMode ) {
      var dt = ngModelCtrl.$viewValue ? new Date( ngModelCtrl.$viewValue ) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );
      ngModelCtrl.$setViewValue( dt );
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) - 1 ];
    }
  };

  $scope.move = function( direction ) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function( direction ) {
    direction = direction || 1;

    if (($scope.datepickerMode === self.maxMode &amp;&amp; direction === 1) || ($scope.datepickerMode === self.minMode &amp;&amp; direction === -1)) {
      return;
    }

    $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) + direction ];
  };

  // Key event mapper
  $scope.keys = { 13:&#x27;enter&#x27;, 32:&#x27;space&#x27;, 33:&#x27;pageup&#x27;, 34:&#x27;pagedown&#x27;, 35:&#x27;end&#x27;, 36:&#x27;home&#x27;, 37:&#x27;left&#x27;, 38:&#x27;up&#x27;, 39:&#x27;right&#x27;, 40:&#x27;down&#x27; };

  var focusElement = function() {
    $timeout(function() {
      self.element[0].focus();
    }, 0 , false);
  };

  // Listen for focus requests from popup directive
  $scope.$on(&#x27;datepicker.focus&#x27;, focusElement);

  $scope.keydown = function( evt ) {
    var key = $scope.keys[evt.which];

    if ( !key || evt.shiftKey || evt.altKey ) {
      return;
    }

    evt.preventDefault();
    if(!self.shortcutPropagation){
        evt.stopPropagation();
    }

    if (key === &#x27;enter&#x27; || key === &#x27;space&#x27;) {
      if ( self.isDisabled(self.activeDate)) {
        return; // do nothing
      }
      $scope.select(self.activeDate);
      focusElement();
    } else if (evt.ctrlKey &amp;&amp; (key === &#x27;up&#x27; || key === &#x27;down&#x27;)) {
      $scope.toggleMode(key === &#x27;up&#x27; ? 1 : -1);
      focusElement();
    } else {
      self.handleKeyDown(key, evt);
      self.refreshView();
    }
  };
}])

.directive( &#x27;datepicker&#x27;, function () {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    templateUrl: &#x27;template/datepicker/datepicker.html&#x27;,
    scope: {
      datepickerMode: &#x27;=?&#x27;,
      dateDisabled: &#x27;&amp;&#x27;,
      customClass: &#x27;&amp;&#x27;,
      shortcutPropagation: &#x27;&amp;?&#x27;
    },
    require: [&#x27;datepicker&#x27;, &#x27;?^ngModel&#x27;],
    controller: &#x27;DatepickerController&#x27;,
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if ( ngModelCtrl ) {
        datepickerCtrl.init( ngModelCtrl );
      }
    }
  };
})

.directive(&#x27;daypicker&#x27;, [&#x27;dateFilter&#x27;, function (dateFilter) {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    templateUrl: &#x27;template/datepicker/day.html&#x27;,
    require: &#x27;^datepicker&#x27;,
    link: function(scope, element, attrs, ctrl) {
      scope.showWeeks = ctrl.showWeeks;

      ctrl.step = { months: 1 };
      ctrl.element = element;

      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function getDaysInMonth( year, month ) {
        return ((month === 1) &amp;&amp; (year % 4 === 0) &amp;&amp; ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];
      }

      function getDates(startDate, n) {
        var dates = new Array(n), current = new Date(startDate), i = 0;
        current.setHours(12); // Prevent repeated dates because of timezone bug
        while ( i &lt; n ) {
          dates[i++] = new Date(current);
          current.setDate( current.getDate() + 1 );
        }
        return dates;
      }

      ctrl._refreshView = function() {
        var year = ctrl.activeDate.getFullYear(),
          month = ctrl.activeDate.getMonth(),
          firstDayOfMonth = new Date(year, month, 1),
          difference = ctrl.startingDay - firstDayOfMonth.getDay(),
          numDisplayedFromPreviousMonth = (difference &gt; 0) ? 7 - difference : - difference,
          firstDate = new Date(firstDayOfMonth);

        if ( numDisplayedFromPreviousMonth &gt; 0 ) {
          firstDate.setDate( - numDisplayedFromPreviousMonth + 1 );
        }

        // 42 is the number of days on a six-month calendar
        var days = getDates(firstDate, 42);
        for (var i = 0; i &lt; 42; i ++) {
          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + &#x27;-&#x27; + i
          });
        }

        scope.labels = new Array(7);
        for (var j = 0; j &lt; 7; j++) {
          scope.labels[j] = {
            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
            full: dateFilter(days[j].date, &#x27;EEEE&#x27;)
          };
        }

        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);
        scope.rows = ctrl.split(days, 7);

        if ( scope.showWeeks ) {
          scope.weekNumbers = [];
          var thursdayIndex = (4 + 7 - ctrl.startingDay) % 7,
              numWeeks = scope.rows.length;
          for (var curWeek = 0; curWeek &lt; numWeeks; curWeek++) {
            scope.weekNumbers.push(
              getISO8601WeekNumber( scope.rows[curWeek][thursdayIndex].date ));
          }
        }
      };

      ctrl.compare = function(date1, date2) {
        return (new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) - new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) );
      };

      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
        var time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }

      ctrl.handleKeyDown = function( key, evt ) {
        var date = ctrl.activeDate.getDate();

        if (key === &#x27;left&#x27;) {
          date = date - 1;   // up
        } else if (key === &#x27;up&#x27;) {
          date = date - 7;   // down
        } else if (key === &#x27;right&#x27;) {
          date = date + 1;   // down
        } else if (key === &#x27;down&#x27;) {
          date = date + 7;
        } else if (key === &#x27;pageup&#x27; || key === &#x27;pagedown&#x27;) {
          var month = ctrl.activeDate.getMonth() + (key === &#x27;pageup&#x27; ? - 1 : 1);
          ctrl.activeDate.setMonth(month, 1);
          date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
        } else if (key === &#x27;home&#x27;) {
          date = 1;
        } else if (key === &#x27;end&#x27;) {
          date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());
        }
        ctrl.activeDate.setDate(date);
      };

      ctrl.refreshView();
    }
  };
}])

.directive(&#x27;monthpicker&#x27;, [&#x27;dateFilter&#x27;, function (dateFilter) {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    templateUrl: &#x27;template/datepicker/month.html&#x27;,
    require: &#x27;^datepicker&#x27;,
    link: function(scope, element, attrs, ctrl) {
      ctrl.step = { years: 1 };
      ctrl.element = element;

      ctrl._refreshView = function() {
        var months = new Array(12),
            year = ctrl.activeDate.getFullYear();

        for ( var i = 0; i &lt; 12; i++ ) {
          months[i] = angular.extend(ctrl.createDateObject(new Date(year, i, 1), ctrl.formatMonth), {
            uid: scope.uniqueId + &#x27;-&#x27; + i
          });
        }

        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);
        scope.rows = ctrl.split(months, 3);
      };

      ctrl.compare = function(date1, date2) {
        return new Date( date1.getFullYear(), date1.getMonth() ) - new Date( date2.getFullYear(), date2.getMonth() );
      };

      ctrl.handleKeyDown = function( key, evt ) {
        var date = ctrl.activeDate.getMonth();

        if (key === &#x27;left&#x27;) {
          date = date - 1;   // up
        } else if (key === &#x27;up&#x27;) {
          date = date - 3;   // down
        } else if (key === &#x27;right&#x27;) {
          date = date + 1;   // down
        } else if (key === &#x27;down&#x27;) {
          date = date + 3;
        } else if (key === &#x27;pageup&#x27; || key === &#x27;pagedown&#x27;) {
          var year = ctrl.activeDate.getFullYear() + (key === &#x27;pageup&#x27; ? - 1 : 1);
          ctrl.activeDate.setFullYear(year);
        } else if (key === &#x27;home&#x27;) {
          date = 0;
        } else if (key === &#x27;end&#x27;) {
          date = 11;
        }
        ctrl.activeDate.setMonth(date);
      };

      ctrl.refreshView();
    }
  };
}])

.directive(&#x27;yearpicker&#x27;, [&#x27;dateFilter&#x27;, function (dateFilter) {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    templateUrl: &#x27;template/datepicker/year.html&#x27;,
    require: &#x27;^datepicker&#x27;,
    link: function(scope, element, attrs, ctrl) {
      var range = ctrl.yearRange;

      ctrl.step = { years: range };
      ctrl.element = element;

      function getStartingYear( year ) {
        return parseInt((year - 1) / range, 10) * range + 1;
      }

      ctrl._refreshView = function() {
        var years = new Array(range);

        for ( var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i &lt; range; i++ ) {
          years[i] = angular.extend(ctrl.createDateObject(new Date(start + i, 0, 1), ctrl.formatYear), {
            uid: scope.uniqueId + &#x27;-&#x27; + i
          });
        }

        scope.title = [years[0].label, years[range - 1].label].join(&#x27; - &#x27;);
        scope.rows = ctrl.split(years, 5);
      };

      ctrl.compare = function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      };

      ctrl.handleKeyDown = function( key, evt ) {
        var date = ctrl.activeDate.getFullYear();

        if (key === &#x27;left&#x27;) {
          date = date - 1;   // up
        } else if (key === &#x27;up&#x27;) {
          date = date - 5;   // down
        } else if (key === &#x27;right&#x27;) {
          date = date + 1;   // down
        } else if (key === &#x27;down&#x27;) {
          date = date + 5;
        } else if (key === &#x27;pageup&#x27; || key === &#x27;pagedown&#x27;) {
          date += (key === &#x27;pageup&#x27; ? - 1 : 1) * ctrl.step.years;
        } else if (key === &#x27;home&#x27;) {
          date = getStartingYear( ctrl.activeDate.getFullYear() );
        } else if (key === &#x27;end&#x27;) {
          date = getStartingYear( ctrl.activeDate.getFullYear() ) + range - 1;
        }
        ctrl.activeDate.setFullYear(date);
      };

      ctrl.refreshView();
    }
  };
}])

.constant(&#x27;datepickerPopupConfig&#x27;, {
  datepickerPopup: &#x27;yyyy-MM-dd&#x27;,
  html5Types: {
    date: &#x27;yyyy-MM-dd&#x27;,
    &#x27;datetime-local&#x27;: &#x27;yyyy-MM-ddTHH:mm:ss.sss&#x27;,
    &#x27;month&#x27;: &#x27;yyyy-MM&#x27;
  },
  currentText: &#x27;Today&#x27;,
  clearText: &#x27;Clear&#x27;,
  closeText: &#x27;Done&#x27;,
  closeOnDateSelection: true,
  appendToBody: false,
  showButtonBar: true
})

.directive(&#x27;datepickerPopup&#x27;, [&#x27;$compile&#x27;, &#x27;$parse&#x27;, &#x27;$document&#x27;, &#x27;$position&#x27;, &#x27;dateFilter&#x27;, &#x27;dateParser&#x27;, &#x27;datepickerPopupConfig&#x27;,
function ($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {
  return {
    restrict: &#x27;EA&#x27;,
    require: &#x27;ngModel&#x27;,
    scope: {
      isOpen: &#x27;=?&#x27;,
      currentText: &#x27;@&#x27;,
      clearText: &#x27;@&#x27;,
      closeText: &#x27;@&#x27;,
      dateDisabled: &#x27;&amp;&#x27;,
      customClass: &#x27;&amp;&#x27;
    },
    link: function(scope, element, attrs, ngModel) {
      var dateFormat,
          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,
          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;

      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;

      scope.getText = function( key ) {
        return scope[key + &#x27;Text&#x27;] || datepickerPopupConfig[key + &#x27;Text&#x27;];
      };

      var isHtml5DateInput = false;
      if (datepickerPopupConfig.html5Types[attrs.type]) {
        dateFormat = datepickerPopupConfig.html5Types[attrs.type];
        isHtml5DateInput = true;
      } else {
        dateFormat = attrs.datepickerPopup || datepickerPopupConfig.datepickerPopup;
        attrs.$observe(&#x27;datepickerPopup&#x27;, function(value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            // Invalidate the $modelValue to ensure that formatters re-run
            // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
            if (newDateFormat !== dateFormat) {
              dateFormat = newDateFormat;
              ngModel.$modelValue = null;

              if (!dateFormat) {
                throw new Error(&#x27;datepickerPopup must have a date format specified.&#x27;);
              }
            }
        });
      }

      if (!dateFormat) {
        throw new Error(&#x27;datepickerPopup must have a date format specified.&#x27;);
      }

      if (isHtml5DateInput &amp;&amp; attrs.datepickerPopup) {
        throw new Error(&#x27;HTML5 date input types do not support custom formats.&#x27;);
      }

      // popup element used to display calendar
      var popupEl = angular.element(&#x27;&lt;div datepicker-popup-wrap&gt;&lt;div datepicker&gt;&lt;/div&gt;&lt;/div&gt;&#x27;);
      popupEl.attr({
        &#x27;ng-model&#x27;: &#x27;date&#x27;,
        &#x27;ng-change&#x27;: &#x27;dateSelection()&#x27;
      });

      function cameltoDash( string ){
        return string.replace(/([A-Z])/g, function($1) { return &#x27;-&#x27; + $1.toLowerCase(); });
      }

      // datepicker element
      var datepickerEl = angular.element(popupEl.children()[0]);
      if (isHtml5DateInput) {
        if (attrs.type == &#x27;month&#x27;) {
          datepickerEl.attr(&#x27;datepicker-mode&#x27;, &#x27;&quot;month&quot;&#x27;);
          datepickerEl.attr(&#x27;min-mode&#x27;, &#x27;month&#x27;);
        }
      }

      if ( attrs.datepickerOptions ) {
        var options = scope.$parent.$eval(attrs.datepickerOptions);
        if(options.initDate) {
          scope.initDate = options.initDate;
          datepickerEl.attr( &#x27;init-date&#x27;, &#x27;initDate&#x27; );
          delete options.initDate;
        }
        angular.forEach(options, function( value, option ) {
          datepickerEl.attr( cameltoDash(option), value );
        });
      }

      scope.watchData = {};
      angular.forEach([&#x27;minDate&#x27;, &#x27;maxDate&#x27;, &#x27;datepickerMode&#x27;, &#x27;initDate&#x27;, &#x27;shortcutPropagation&#x27;], function( key ) {
        if ( attrs[key] ) {
          var getAttribute = $parse(attrs[key]);
          scope.$parent.$watch(getAttribute, function(value){
            scope.watchData[key] = value;
          });
          datepickerEl.attr(cameltoDash(key), &#x27;watchData.&#x27; + key);

          // Propagate changes from datepicker to outside
          if ( key === &#x27;datepickerMode&#x27; ) {
            var setAttribute = getAttribute.assign;
            scope.$watch(&#x27;watchData.&#x27; + key, function(value, oldvalue) {
              if ( value !== oldvalue ) {
                setAttribute(scope.$parent, value);
              }
            });
          }
        }
      });
      if (attrs.dateDisabled) {
        datepickerEl.attr(&#x27;date-disabled&#x27;, &#x27;dateDisabled({ date: date, mode: mode })&#x27;);
      }

      if (attrs.showWeeks) {
        datepickerEl.attr(&#x27;show-weeks&#x27;, attrs.showWeeks);
      }

      if (attrs.customClass){
        datepickerEl.attr(&#x27;custom-class&#x27;, &#x27;customClass({ date: date, mode: mode })&#x27;);
      }

      function parseDate(viewValue) {
        if (angular.isNumber(viewValue)) {
          // presumably timestamp to date object
          viewValue = new Date(viewValue);
        }

        if (!viewValue) {
          return null;
        } else if (angular.isDate(viewValue) &amp;&amp; !isNaN(viewValue)) {
          return viewValue;
        } else if (angular.isString(viewValue)) {
          var date = dateParser.parse(viewValue, dateFormat, scope.date) || new Date(viewValue);
          if (isNaN(date)) {
            return undefined;
          } else {
            return date;
          }
        } else {
          return undefined;
        }
      }

      function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;
        if (angular.isNumber(value)) {
          value = new Date(value);
        }
        if (!value) {
          return true;
        } else if (angular.isDate(value) &amp;&amp; !isNaN(value)) {
          return true;
        } else if (angular.isString(value)) {
          var date = dateParser.parse(value, dateFormat) || new Date(value);
          return !isNaN(date);
        } else {
          return false;
        }
      }

      if (!isHtml5DateInput) {
        // Internal API to maintain the correct ng-invalid-[key] class
        ngModel.$$parserName = &#x27;date&#x27;;
        ngModel.$validators.date = validator;
        ngModel.$parsers.unshift(parseDate);
        ngModel.$formatters.push(function (value) {
          scope.date = value;
          return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
        });
      }
      else {
        ngModel.$formatters.push(function (value) {
          scope.date = value;
          return value;
        });
      }

      // Inner change
      scope.dateSelection = function(dt) {
        if (angular.isDefined(dt)) {
          scope.date = dt;
        }
        var date = scope.date ? dateFilter(scope.date, dateFormat) : &#x27;&#x27;;
        element.val(date);
        ngModel.$setViewValue(date);

        if ( closeOnDateSelection ) {
          scope.isOpen = false;
          element[0].focus();
        }
      };

      // Detect changes in the view from the text box
      ngModel.$viewChangeListeners.push(function () {
        scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date) || new Date(ngModel.$viewValue);
      });

      var documentClickBind = function(event) {
        if (scope.isOpen &amp;&amp; event.target !== element[0]) {
          scope.$apply(function() {
            scope.isOpen = false;
          });
        }
      };

      var keydown = function(evt, noApply) {
        scope.keydown(evt);
      };
      element.bind(&#x27;keydown&#x27;, keydown);

      scope.keydown = function(evt) {
        if (evt.which === 27) {
          evt.preventDefault();
          if (scope.isOpen) {
            evt.stopPropagation();
          }
          scope.close();
        } else if (evt.which === 40 &amp;&amp; !scope.isOpen) {
          scope.isOpen = true;
        }
      };

      scope.$watch(&#x27;isOpen&#x27;, function(value) {
        if (value) {
          scope.$broadcast(&#x27;datepicker.focus&#x27;);
          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
          scope.position.top = scope.position.top + element.prop(&#x27;offsetHeight&#x27;);

          $document.bind(&#x27;click&#x27;, documentClickBind);
        } else {
          $document.unbind(&#x27;click&#x27;, documentClickBind);
        }
      });

      scope.select = function( date ) {
        if (date === &#x27;today&#x27;) {
          var today = new Date();
          if (angular.isDate(scope.date)) {
            date = new Date(scope.date);
            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
          } else {
            date = new Date(today.setHours(0, 0, 0, 0));
          }
        }
        scope.dateSelection( date );
      };

      scope.close = function() {
        scope.isOpen = false;
        element[0].focus();
      };

      var $popup = $compile(popupEl)(scope);
      // Prevent jQuery cache memory leak (template is now redundant after linking)
      popupEl.remove();

      if ( appendToBody ) {
        $document.find(&#x27;body&#x27;).append($popup);
      } else {
        element.after($popup);
      }

      scope.$on(&#x27;$destroy&#x27;, function() {
        $popup.remove();
        element.unbind(&#x27;keydown&#x27;, keydown);
        $document.unbind(&#x27;click&#x27;, documentClickBind);
      });
    }
  };
}])

.directive(&#x27;datepickerPopupWrap&#x27;, function() {
  return {
    restrict:&#x27;EA&#x27;,
    replace: true,
    transclude: true,
    templateUrl: &#x27;template/datepicker/popup.html&#x27;,
    link:function (scope, element, attrs) {
      element.bind(&#x27;click&#x27;, function(event) {
        event.preventDefault();
        event.stopPropagation();
      });
    }
  };
});

angular.module(&#x27;ui.bootstrap.dropdown&#x27;, [&#x27;ui.bootstrap.position&#x27;])

.constant(&#x27;dropdownConfig&#x27;, {
  openClass: &#x27;open&#x27;
})

.service(&#x27;dropdownService&#x27;, [&#x27;$document&#x27;, &#x27;$rootScope&#x27;, function($document, $rootScope) {
  var openScope = null;

  this.open = function( dropdownScope ) {
    if ( !openScope ) {
      $document.bind(&#x27;click&#x27;, closeDropdown);
      $document.bind(&#x27;keydown&#x27;, escapeKeyBind);
    }

    if ( openScope &amp;&amp; openScope !== dropdownScope ) {
        openScope.isOpen = false;
    }

    openScope = dropdownScope;
  };

  this.close = function( dropdownScope ) {
    if ( openScope === dropdownScope ) {
      openScope = null;
      $document.unbind(&#x27;click&#x27;, closeDropdown);
      $document.unbind(&#x27;keydown&#x27;, escapeKeyBind);
    }
  };

  var closeDropdown = function( evt ) {
    // This method may still be called during the same mouse event that
    // unbound this event handler. So check openScope before proceeding.
    if (!openScope) { return; }

    if( evt &amp;&amp; openScope.getAutoClose() === &#x27;disabled&#x27; )  { return ; }

    var toggleElement = openScope.getToggleElement();
    if ( evt &amp;&amp; toggleElement &amp;&amp; toggleElement[0].contains(evt.target) ) {
        return;
    }

    var $element = openScope.getElement();
    if( evt &amp;&amp; openScope.getAutoClose() === &#x27;outsideClick&#x27; &amp;&amp; $element &amp;&amp; $element[0].contains(evt.target) ) {
      return;
    }

    openScope.isOpen = false;

    if (!$rootScope.$$phase) {
      openScope.$apply();
    }
  };

  var escapeKeyBind = function( evt ) {
    if ( evt.which === 27 ) {
      openScope.focusToggleElement();
      closeDropdown();
    }
  };
}])

.controller(&#x27;DropdownController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;$parse&#x27;, &#x27;dropdownConfig&#x27;, &#x27;dropdownService&#x27;, &#x27;$animate&#x27;, &#x27;$position&#x27;, &#x27;$document&#x27;, function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate, $position, $document) {
  var self = this,
      scope = $scope.$new(), // create a child scope so we are not polluting original one
      openClass = dropdownConfig.openClass,
      getIsOpen,
      setIsOpen = angular.noop,
      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
      appendToBody = false;

  this.init = function( element ) {
    self.$element = element;

    if ( $attrs.isOpen ) {
      getIsOpen = $parse($attrs.isOpen);
      setIsOpen = getIsOpen.assign;

      $scope.$watch(getIsOpen, function(value) {
        scope.isOpen = !!value;
      });
    }

    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);

    if ( appendToBody &amp;&amp; self.dropdownMenu ) {
      $document.find(&#x27;body&#x27;).append( self.dropdownMenu );
      element.on(&#x27;$destroy&#x27;, function handleDestroyEvent() {
        self.dropdownMenu.remove();
      });
    }
  };

  this.toggle = function( open ) {
    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
  };

  // Allow other directives to watch status
  this.isOpen = function() {
    return scope.isOpen;
  };

  scope.getToggleElement = function() {
    return self.toggleElement;
  };

  scope.getAutoClose = function() {
    return $attrs.autoClose || &#x27;always&#x27;; //or &#x27;outsideClick&#x27; or &#x27;disabled&#x27;
  };

  scope.getElement = function() {
    return self.$element;
  };

  scope.focusToggleElement = function() {
    if ( self.toggleElement ) {
      self.toggleElement[0].focus();
    }
  };

  scope.$watch(&#x27;isOpen&#x27;, function( isOpen, wasOpen ) {
    if ( appendToBody &amp;&amp; self.dropdownMenu ) {
      var pos = $position.positionElements(self.$element, self.dropdownMenu, &#x27;bottom-left&#x27;, true);
      self.dropdownMenu.css({
        top: pos.top + &#x27;px&#x27;,
        left: pos.left + &#x27;px&#x27;,
        display: isOpen ? &#x27;block&#x27; : &#x27;none&#x27;
      });
    }

    $animate[isOpen ? &#x27;addClass&#x27; : &#x27;removeClass&#x27;](self.$element, openClass);

    if ( isOpen ) {
      scope.focusToggleElement();
      dropdownService.open( scope );
    } else {
      dropdownService.close( scope );
    }

    setIsOpen($scope, isOpen);
    if (angular.isDefined(isOpen) &amp;&amp; isOpen !== wasOpen) {
      toggleInvoker($scope, { open: !!isOpen });
    }
  });

  $scope.$on(&#x27;$locationChangeSuccess&#x27;, function() {
    scope.isOpen = false;
  });

  $scope.$on(&#x27;$destroy&#x27;, function() {
    scope.$destroy();
  });
}])

.directive(&#x27;dropdown&#x27;, function() {
  return {
    controller: &#x27;DropdownController&#x27;,
    link: function(scope, element, attrs, dropdownCtrl) {
      dropdownCtrl.init( element );
    }
  };
})

.directive(&#x27;dropdownMenu&#x27;, function() {
  return {
    restrict: &#x27;AC&#x27;,
    require: &#x27;?^dropdown&#x27;,
    link: function(scope, element, attrs, dropdownCtrl) {
      if ( !dropdownCtrl ) {
        return;
      }
      dropdownCtrl.dropdownMenu = element;
    }
  };
})

.directive(&#x27;dropdownToggle&#x27;, function() {
  return {
    require: &#x27;?^dropdown&#x27;,
    link: function(scope, element, attrs, dropdownCtrl) {
      if ( !dropdownCtrl ) {
        return;
      }

      dropdownCtrl.toggleElement = element;

      var toggleDropdown = function(event) {
        event.preventDefault();

        if ( !element.hasClass(&#x27;disabled&#x27;) &amp;&amp; !attrs.disabled ) {
          scope.$apply(function() {
            dropdownCtrl.toggle();
          });
        }
      };

      element.bind(&#x27;click&#x27;, toggleDropdown);

      // WAI-ARIA
      element.attr({ &#x27;aria-haspopup&#x27;: true, &#x27;aria-expanded&#x27;: false });
      scope.$watch(dropdownCtrl.isOpen, function( isOpen ) {
        element.attr(&#x27;aria-expanded&#x27;, !!isOpen);
      });

      scope.$on(&#x27;$destroy&#x27;, function() {
        element.unbind(&#x27;click&#x27;, toggleDropdown);
      });
    }
  };
});

angular.module(&#x27;ui.bootstrap.modal&#x27;, [])

/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory(&#x27;$$stackedMap&#x27;, function () {
    return {
      createNew: function () {
        var stack = [];

        return {
          add: function (key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function (key) {
            for (var i = 0; i &lt; stack.length; i++) {
              if (key == stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i &lt; stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function () {
            return stack[stack.length - 1];
          },
          remove: function (key) {
            var idx = -1;
            for (var i = 0; i &lt; stack.length; i++) {
              if (key == stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function () {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function () {
            return stack.length;
          }
        };
      }
    };
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive(&#x27;modalBackdrop&#x27;, [&#x27;$timeout&#x27;, function ($timeout) {
    return {
      restrict: &#x27;EA&#x27;,
      replace: true,
      templateUrl: &#x27;template/modal/backdrop.html&#x27;,
      compile: function (tElement, tAttrs) {
        tElement.addClass(tAttrs.backdropClass);
        return linkFn;
      }
    };

    function linkFn(scope, element, attrs) {
      scope.animate = false;

      //trigger CSS transitions
      $timeout(function () {
        scope.animate = true;
      });
    }
  }])

  .directive(&#x27;modalWindow&#x27;, [&#x27;$modalStack&#x27;, &#x27;$q&#x27;, function ($modalStack, $q) {
    return {
      restrict: &#x27;EA&#x27;,
      scope: {
        index: &#x27;@&#x27;,
        animate: &#x27;=&#x27;
      },
      replace: true,
      transclude: true,
      templateUrl: function(tElement, tAttrs) {
        return tAttrs.templateUrl || &#x27;template/modal/window.html&#x27;;
      },
      link: function (scope, element, attrs) {
        element.addClass(attrs.windowClass || &#x27;&#x27;);
        scope.size = attrs.size;

        scope.close = function (evt) {
          var modal = $modalStack.getTop();
          if (modal &amp;&amp; modal.value.backdrop &amp;&amp; modal.value.backdrop != &#x27;static&#x27; &amp;&amp; (evt.target === evt.currentTarget)) {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, &#x27;backdrop click&#x27;);
          }
        };

        // This property is only added to the scope for the purpose of detecting when this directive is rendered.
        // We can detect that by using this property in the template associated with this directive and then use
        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
        scope.$isRendered = true;

        // Deferred object that will be resolved when this modal is render.
        var modalRenderDeferObj = $q.defer();
        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal&#x27;s template.
        attrs.$observe(&#x27;modalRender&#x27;, function (value) {
          if (value == &#x27;true&#x27;) {
            modalRenderDeferObj.resolve();
          }
        });

        modalRenderDeferObj.promise.then(function () {
          // trigger CSS transitions
          scope.animate = true;

          var inputsWithAutofocus = element[0].querySelectorAll(&#x27;[autofocus]&#x27;);
          /**
           * Auto-focusing of a freshly-opened modal element causes any child elements
           * with the autofocus attribute to lose focus. This is an issue on touch
           * based devices which will show and then hide the onscreen keyboard.
           * Attempts to refocus the autofocus element via JavaScript will not reopen
           * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
           * the modal element if the modal does not contain an autofocus element.
           */
          if (inputsWithAutofocus.length) {
            inputsWithAutofocus[0].focus();
          } else {
            element[0].focus();
          }

          // Notify {@link $modalStack} that modal is rendered.
          var modal = $modalStack.getTop();
          if (modal) {
            $modalStack.modalRendered(modal.key);
          }
        });
      }
    };
  }])

  .directive(&#x27;modalAnimationClass&#x27;, [
    function () {
      return {
        compile: function (tElement, tAttrs) {
          if (tAttrs.modalAnimation) {
            tElement.addClass(tAttrs.modalAnimationClass);
          }
        }
      };
    }])

  .directive(&#x27;modalTransclude&#x27;, function () {
    return {
      link: function($scope, $element, $attrs, controller, $transclude) {
        $transclude($scope.$parent, function(clone) {
          $element.empty();
          $element.append(clone);
        });
      }
    };
  })

  .factory(&#x27;$modalStack&#x27;, [&#x27;$animate&#x27;, &#x27;$timeout&#x27;, &#x27;$document&#x27;, &#x27;$compile&#x27;, &#x27;$rootScope&#x27;, &#x27;$$stackedMap&#x27;,
    function ($animate, $timeout, $document, $compile, $rootScope, $$stackedMap) {

      var OPENED_MODAL_CLASS = &#x27;modal-open&#x27;;

      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var $modalStack = {};

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i &lt; opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex){
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance) {

        var body = $document.find(&#x27;body&#x27;).eq(0);
        var modalWindow = openedWindows.get(modalInstance).value;

        //clean up the stack
        openedWindows.remove(modalInstance);

        //remove window DOM element
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() &gt; 0);
          checkRemoveBackdrop();
        });
      }

      function checkRemoveBackdrop() {
          //remove backdrop if no longer needed
          if (backdropDomEl &amp;&amp; backdropIndex() == -1) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, function () {
              backdropScopeRef = null;
            });
            backdropDomEl = undefined;
            backdropScope = undefined;
          }
      }

      function removeAfterAnimate(domEl, scope, done) {
        // Closing animation
        scope.animate = false;

        if (domEl.attr(&#x27;modal-animation&#x27;) &amp;&amp; $animate.enabled()) {
          // transition out
          domEl.one(&#x27;$animate:close&#x27;, function closeFn() {
            $rootScope.$evalAsync(afterAnimating);
          });
        } else {
          // Ensure this call is async
          $timeout(afterAnimating);
        }

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;

          domEl.remove();
          scope.$destroy();
          if (done) {
            done();
          }
        }
      }

      $document.bind(&#x27;keydown&#x27;, function (evt) {
        var modal;

        if (evt.which === 27) {
          modal = openedWindows.top();
          if (modal &amp;&amp; modal.value.keyboard) {
            evt.preventDefault();
            $rootScope.$apply(function () {
              $modalStack.dismiss(modal.key, &#x27;escape key press&#x27;);
            });
          }
        }
      });

      $modalStack.open = function (modalInstance, modal) {

        var modalOpener = $document[0].activeElement;

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard
        });

        var body = $document.find(&#x27;body&#x27;).eq(0),
            currBackdropIndex = backdropIndex();

        if (currBackdropIndex &gt;= 0 &amp;&amp; !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.index = currBackdropIndex;
          var angularBackgroundDomEl = angular.element(&#x27;&lt;div modal-backdrop=&quot;modal-backdrop&quot;&gt;&lt;/div&gt;&#x27;);
          angularBackgroundDomEl.attr(&#x27;backdrop-class&#x27;, modal.backdropClass);
          if (modal.animation) {
            angularBackgroundDomEl.attr(&#x27;modal-animation&#x27;, &#x27;true&#x27;);
          }
          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
          body.append(backdropDomEl);
        }

        var angularDomEl = angular.element(&#x27;&lt;div modal-window=&quot;modal-window&quot;&gt;&lt;/div&gt;&#x27;);
        angularDomEl.attr({
          &#x27;template-url&#x27;: modal.windowTemplateUrl,
          &#x27;window-class&#x27;: modal.windowClass,
          &#x27;size&#x27;: modal.size,
          &#x27;index&#x27;: openedWindows.length() - 1,
          &#x27;animate&#x27;: &#x27;animate&#x27;
        }).html(modal.content);
        if (modal.animation) {
          angularDomEl.attr(&#x27;modal-animation&#x27;, &#x27;true&#x27;);
        }

        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
        body.append(modalDomEl);
        body.addClass(OPENED_MODAL_CLASS);
      };

      function broadcastClosing(modalWindow, resultOrReason, closing) {
          return !modalWindow.value.modalScope.$broadcast(&#x27;modal.closing&#x27;, resultOrReason, closing).defaultPrevented;
      }

      $modalStack.close = function (modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow &amp;&amp; broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance);
          modalWindow.value.modalOpener.focus();
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismiss = function (modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow &amp;&amp; broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance);
          modalWindow.value.modalOpener.focus();
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismissAll = function (reason) {
        var topModal = this.getTop();
        while (topModal &amp;&amp; this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };

      $modalStack.getTop = function () {
        return openedWindows.top();
      };

      $modalStack.modalRendered = function (modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };

      return $modalStack;
    }])

  .provider(&#x27;$modal&#x27;, function () {

    var $modalProvider = {
      options: {
        animation: true,
        backdrop: true, //can also be false or &#x27;static&#x27;
        keyboard: true
      },
      $get: [&#x27;$injector&#x27;, &#x27;$rootScope&#x27;, &#x27;$q&#x27;, &#x27;$templateRequest&#x27;, &#x27;$controller&#x27;, &#x27;$modalStack&#x27;,
        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack) {

          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);
          }

          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function (value) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              }
            });
            return promisesArr;
          }

          $modal.open = function (modalOptions) {

            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function (result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};

            //verify options
            if (!modalOptions.template &amp;&amp; !modalOptions.templateUrl) {
              throw new Error(&#x27;One of template or templateUrl options is required.&#x27;);
            }

            var templateAndResolvePromise =
              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));


            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {

              var modalScope = (modalOptions.scope || $rootScope).$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;

              var ctrlInstance, ctrlLocals = {};
              var resolveIter = 1;

              //controllers
              if (modalOptions.controller) {
                ctrlLocals.$scope = modalScope;
                ctrlLocals.$modalInstance = modalInstance;
                angular.forEach(modalOptions.resolve, function (value, key) {
                  ctrlLocals[key] = tplAndVars[resolveIter++];
                });

                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                if (modalOptions.controllerAs) {
                  modalScope[modalOptions.controllerAs] = ctrlInstance;
                }
              }

              $modalStack.open(modalInstance, {
                scope: modalScope,
                deferred: modalResultDeferred,
                renderDeferred: modalRenderDeferred,
                content: tplAndVars[0],
                animation: modalOptions.animation,
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                backdropClass: modalOptions.backdropClass,
                windowClass: modalOptions.windowClass,
                windowTemplateUrl: modalOptions.windowTemplateUrl,
                size: modalOptions.size
              });

            }, function resolveError(reason) {
              modalResultDeferred.reject(reason);
            });

            templateAndResolvePromise.then(function () {
              modalOpenedDeferred.resolve(true);
            }, function (reason) {
              modalOpenedDeferred.reject(reason);
            });

            return modalInstance;
          };

          return $modal;
        }]
    };

    return $modalProvider;
  });

angular.module(&#x27;ui.bootstrap.pagination&#x27;, [])

.controller(&#x27;PaginationController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;$parse&#x27;, function ($scope, $attrs, $parse) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

  this.init = function(ngModelCtrl_, config) {
    ngModelCtrl = ngModelCtrl_;
    this.config = config;

    ngModelCtrl.$render = function() {
      self.render();
    };

    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = config.itemsPerPage;
    }

    $scope.$watch(&#x27;totalItems&#x27;, function() {
      $scope.totalPages = self.calculateTotalPages();
    });

    $scope.$watch(&#x27;totalPages&#x27;, function(value) {
      setNumPages($scope.$parent, value); // Readonly variable

      if ( $scope.page &gt; value ) {
        $scope.selectPage(value);
      } else {
        ngModelCtrl.$render();
      }
    });
  };

  this.calculateTotalPages = function() {
    var totalPages = this.itemsPerPage &lt; 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
    return Math.max(totalPages || 0, 1);
  };

  this.render = function() {
    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
  };

  $scope.selectPage = function(page, evt) {
    if ( $scope.page !== page &amp;&amp; page &gt; 0 &amp;&amp; page &lt;= $scope.totalPages) {
      if (evt &amp;&amp; evt.target) {
        evt.target.blur();
      }
      ngModelCtrl.$setViewValue(page);
      ngModelCtrl.$render();
    }
  };

  $scope.getText = function( key ) {
    return $scope[key + &#x27;Text&#x27;] || self.config[key + &#x27;Text&#x27;];
  };
  $scope.noPrevious = function() {
    return $scope.page === 1;
  };
  $scope.noNext = function() {
    return $scope.page === $scope.totalPages;
  };
}])

.constant(&#x27;paginationConfig&#x27;, {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: &#x27;First&#x27;,
  previousText: &#x27;Previous&#x27;,
  nextText: &#x27;Next&#x27;,
  lastText: &#x27;Last&#x27;,
  rotate: true
})

.directive(&#x27;pagination&#x27;, [&#x27;$parse&#x27;, &#x27;paginationConfig&#x27;, function($parse, paginationConfig) {
  return {
    restrict: &#x27;EA&#x27;,
    scope: {
      totalItems: &#x27;=&#x27;,
      firstText: &#x27;@&#x27;,
      previousText: &#x27;@&#x27;,
      nextText: &#x27;@&#x27;,
      lastText: &#x27;@&#x27;
    },
    require: [&#x27;pagination&#x27;, &#x27;?ngModel&#x27;],
    controller: &#x27;PaginationController&#x27;,
    templateUrl: &#x27;template/pagination/pagination.html&#x27;,
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      // Setup configuration parameters
      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;

      paginationCtrl.init(ngModelCtrl, paginationConfig);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }

      function getPages(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = ( angular.isDefined(maxSize) &amp;&amp; maxSize &lt; totalPages );

        // recompute if maxSize
        if ( isMaxSized ) {
          if ( rotate ) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage &gt; totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number &lt;= endPage; number++) {
          var page = makePage(number, number, number === currentPage);
          pages.push(page);
        }

        // Add links to move between page sets
        if ( isMaxSized &amp;&amp; ! rotate ) {
          if ( startPage &gt; 1 ) {
            var previousPageSet = makePage(startPage - 1, &#x27;...&#x27;, false);
            pages.unshift(previousPageSet);
          }

          if ( endPage &lt; totalPages ) {
            var nextPageSet = makePage(endPage + 1, &#x27;...&#x27;, false);
            pages.push(nextPageSet);
          }
        }

        return pages;
      }

      var originalRender = paginationCtrl.render;
      paginationCtrl.render = function() {
        originalRender();
        if (scope.page &gt; 0 &amp;&amp; scope.page &lt;= scope.totalPages) {
          scope.pages = getPages(scope.page, scope.totalPages);
        }
      };
    }
  };
}])

.constant(&#x27;pagerConfig&#x27;, {
  itemsPerPage: 10,
  previousText: &#x27; Previous&#x27;,
  nextText: &#x27;Next &#x27;,
  align: true
})

.directive(&#x27;pager&#x27;, [&#x27;pagerConfig&#x27;, function(pagerConfig) {
  return {
    restrict: &#x27;EA&#x27;,
    scope: {
      totalItems: &#x27;=&#x27;,
      previousText: &#x27;@&#x27;,
      nextText: &#x27;@&#x27;
    },
    require: [&#x27;pager&#x27;, &#x27;?ngModel&#x27;],
    controller: &#x27;PaginationController&#x27;,
    templateUrl: &#x27;template/pagination/pager.html&#x27;,
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
      paginationCtrl.init(ngModelCtrl, pagerConfig);
    }
  };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module( &#x27;ui.bootstrap.tooltip&#x27;, [ &#x27;ui.bootstrap.position&#x27;, &#x27;ui.bootstrap.bindHtml&#x27; ] )

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider( &#x27;$tooltip&#x27;, function () {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: &#x27;top&#x27;,
    animation: true,
    popupDelay: 0,
    useContentExp: false
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    &#x27;mouseenter&#x27;: &#x27;mouseleave&#x27;,
    &#x27;click&#x27;: &#x27;click&#x27;,
    &#x27;focus&#x27;: &#x27;blur&#x27;
  };

  // The options specified to the provider globally.
  var globalOptions = {};

  /**
   * &#x60;options({})&#x60; allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( &#x27;App&#x27;, [&#x27;ui.bootstrap.tooltip&#x27;], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: &#x27;left&#x27; } );
   *   });
   */
	this.options = function( value ) {
		angular.extend( globalOptions, value );
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( &#x27;openTrigger&#x27;: &#x27;closeTrigger&#x27; );
   */
  this.setTriggers = function setTriggers ( triggers ) {
    angular.extend( triggerMap, triggers );
  };

  /**
   * This is a helper function for translating camel-case to snake-case.
   */
  function snake_case(name){
    var regexp = /[A-Z]/g;
    var separator = &#x27;-&#x27;;
    return name.replace(regexp, function(letter, pos) {
      return (pos ? separator : &#x27;&#x27;) + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = [ &#x27;$window&#x27;, &#x27;$compile&#x27;, &#x27;$timeout&#x27;, &#x27;$document&#x27;, &#x27;$position&#x27;, &#x27;$interpolate&#x27;, function ( $window, $compile, $timeout, $document, $position, $interpolate ) {
    return function $tooltip ( type, prefix, defaultTriggerShow, options ) {
      options = angular.extend( {}, defaultOptions, globalOptions, options );

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the &#x60;trigger&#x60;
       * option passed to the &#x60;$tooltipProvider.options&#x60; method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the &#x60;trigger&#x60; option
       * was passed to the &#x60;$tooltipProvider.options&#x60; method, it will use the
       * mapped trigger from &#x60;triggerMap&#x60; or the passed trigger if the map is
       * undefined; otherwise, it uses the &#x60;triggerMap&#x60; value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers ( trigger ) {
        var show = trigger || options.trigger || defaultTriggerShow;
        var hide = triggerMap[show] || show;
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case( type );

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template =
        &#x27;&lt;div &#x27;+ directiveName +&#x27;-popup &#x27;+
          &#x27;title=&quot;&#x27;+startSym+&#x27;title&#x27;+endSym+&#x27;&quot; &#x27;+
          (options.useContentExp ?
            &#x27;content-exp=&quot;contentExp()&quot; &#x27; :
            &#x27;content=&quot;&#x27;+startSym+&#x27;content&#x27;+endSym+&#x27;&quot; &#x27;) +
          &#x27;placement=&quot;&#x27;+startSym+&#x27;placement&#x27;+endSym+&#x27;&quot; &#x27;+
          &#x27;popup-class=&quot;&#x27;+startSym+&#x27;popupClass&#x27;+endSym+&#x27;&quot; &#x27;+
          &#x27;animation=&quot;animation&quot; &#x27;+
          &#x27;is-open=&quot;isOpen&quot;&#x27;+
          &#x27;origin-scope=&quot;origScope&quot; &#x27;+
          &#x27;&gt;&#x27;+
        &#x27;&lt;/div&gt;&#x27;;

      return {
        restrict: &#x27;EA&#x27;,
        compile: function (tElem, tAttrs) {
          var tooltipLinker = $compile( template );

          return function link ( scope, element, attrs, tooltipCtrl ) {
            var tooltip;
            var tooltipLinkedScope;
            var transitionTimeout;
            var popupTimeout;
            var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;
            var triggers = getTriggers( undefined );
            var hasEnableExp = angular.isDefined(attrs[prefix+&#x27;Enable&#x27;]);
            var ttScope = scope.$new(true);

            var positionTooltip = function () {
              if (!tooltip) { return; }

              var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
              ttPosition.top += &#x27;px&#x27;;
              ttPosition.left += &#x27;px&#x27;;

              // Now set the calculated positioning.
              tooltip.css( ttPosition );
            };

            // Set up the correct scope to allow transclusion later
            ttScope.origScope = scope;

            // By default, the tooltip is not open.
            // TODO add ability to start tooltip opened
            ttScope.isOpen = false;

            function toggleTooltipBind () {
              if ( ! ttScope.isOpen ) {
                showTooltipBind();
              } else {
                hideTooltipBind();
              }
            }

            // Show the tooltip with delay if specified, otherwise show it immediately
            function showTooltipBind() {
              if(hasEnableExp &amp;&amp; !scope.$eval(attrs[prefix+&#x27;Enable&#x27;])) {
                return;
              }

              prepareTooltip();

              if ( ttScope.popupDelay ) {
                // Do nothing if the tooltip was already scheduled to pop-up.
                // This happens if show is triggered multiple times before any hide is triggered.
                if (!popupTimeout) {
                  popupTimeout = $timeout( show, ttScope.popupDelay, false );
                  popupTimeout.then(function(reposition){reposition();});
                }
              } else {
                show()();
              }
            }

            function hideTooltipBind () {
              scope.$apply(function () {
                hide();
              });
            }

            // Show the tooltip popup element.
            function show() {

              popupTimeout = null;

              // If there is a pending remove transition, we must cancel it, lest the
              // tooltip be mysteriously removed.
              if ( transitionTimeout ) {
                $timeout.cancel( transitionTimeout );
                transitionTimeout = null;
              }

              // Don&#x27;t show empty tooltips.
              if ( !(options.useContentExp ? ttScope.contentExp() : ttScope.content) ) {
                return angular.noop;
              }

              createTooltip();

              // Set the initial positioning.
              tooltip.css({ top: 0, left: 0, display: &#x27;block&#x27; });
              ttScope.$digest();

              positionTooltip();

              // And show the tooltip.
              ttScope.isOpen = true;
              ttScope.$apply(); // digest required as $apply is not called

              // Return positioning function as promise callback for correct
              // positioning after draw.
              return positionTooltip;
            }

            // Hide the tooltip popup element.
            function hide() {
              // First things first: we don&#x27;t show it anymore.
              ttScope.isOpen = false;

              //if tooltip is going to be shown after delay, we must cancel this
              $timeout.cancel( popupTimeout );
              popupTimeout = null;

              // And now we remove it from the DOM. However, if we have animation, we
              // need to wait for it to expire beforehand.
              // FIXME: this is a placeholder for a port of the transitions library.
              if ( ttScope.animation ) {
                if (!transitionTimeout) {
                  transitionTimeout = $timeout(removeTooltip, 500);
                }
              } else {
                removeTooltip();
              }
            }

            function createTooltip() {
              // There can only be one tooltip element per directive shown at once.
              if (tooltip) {
                removeTooltip();
              }
              tooltipLinkedScope = ttScope.$new();
              tooltip = tooltipLinker(tooltipLinkedScope, function (tooltip) {
                if ( appendToBody ) {
                  $document.find( &#x27;body&#x27; ).append( tooltip );
                } else {
                  element.after( tooltip );
                }
              });

              tooltipLinkedScope.$watch(function () {
                $timeout(positionTooltip, 0, false);
              });

              if (options.useContentExp) {
                tooltipLinkedScope.$watch(&#x27;contentExp()&#x27;, function (val) {
                  if (!val &amp;&amp; ttScope.isOpen ) {
                    hide();
                  }
                });
              }
            }

            function removeTooltip() {
              transitionTimeout = null;
              if (tooltip) {
                tooltip.remove();
                tooltip = null;
              }
              if (tooltipLinkedScope) {
                tooltipLinkedScope.$destroy();
                tooltipLinkedScope = null;
              }
            }

            function prepareTooltip() {
              prepPopupClass();
              prepPlacement();
              prepPopupDelay();
            }

            ttScope.contentExp = function () {
              return scope.$eval(attrs[type]);
            };

            /**
             * Observe the relevant attributes.
             */
            if (!options.useContentExp) {
              attrs.$observe( type, function ( val ) {
                ttScope.content = val;

                if (!val &amp;&amp; ttScope.isOpen ) {
                  hide();
                }
              });
            }

            attrs.$observe( &#x27;disabled&#x27;, function ( val ) {
              if (val &amp;&amp; ttScope.isOpen ) {
                hide();
              }
            });

            attrs.$observe( prefix+&#x27;Title&#x27;, function ( val ) {
              ttScope.title = val;
            });

            function prepPopupClass() {
              ttScope.popupClass = attrs[prefix + &#x27;Class&#x27;];
            }

            function prepPlacement() {
              var val = attrs[ prefix + &#x27;Placement&#x27; ];
              ttScope.placement = angular.isDefined( val ) ? val : options.placement;
            }

            function prepPopupDelay() {
              var val = attrs[ prefix + &#x27;PopupDelay&#x27; ];
              var delay = parseInt( val, 10 );
              ttScope.popupDelay = ! isNaN(delay) ? delay : options.popupDelay;
            }

            var unregisterTriggers = function () {
              element.unbind(triggers.show, showTooltipBind);
              element.unbind(triggers.hide, hideTooltipBind);
            };

            function prepTriggers() {
              var val = attrs[ prefix + &#x27;Trigger&#x27; ];
              unregisterTriggers();

              triggers = getTriggers( val );

              if ( triggers.show === triggers.hide ) {
                element.bind( triggers.show, toggleTooltipBind );
              } else {
                element.bind( triggers.show, showTooltipBind );
                element.bind( triggers.hide, hideTooltipBind );
              }
            }
            prepTriggers();

            var animation = scope.$eval(attrs[prefix + &#x27;Animation&#x27;]);
            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

            var appendToBodyVal = scope.$eval(attrs[prefix + &#x27;AppendToBody&#x27;]);
            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

            // if a tooltip is attached to &lt;body&gt; we need to remove it on
            // location change as its parent scope will probably not be destroyed
            // by the change.
            if ( appendToBody ) {
              scope.$on(&#x27;$locationChangeSuccess&#x27;, function closeTooltipOnLocationChangeSuccess () {
              if ( ttScope.isOpen ) {
                hide();
              }
            });
            }

            // Make sure tooltip is destroyed and removed.
            scope.$on(&#x27;$destroy&#x27;, function onDestroyTooltip() {
              $timeout.cancel( transitionTimeout );
              $timeout.cancel( popupTimeout );
              unregisterTriggers();
              removeTooltip();
              ttScope = null;
            });
          };
        }
      };
    };
  }];
})

// This is mostly ngInclude code but with a custom scope
.directive( &#x27;tooltipTemplateTransclude&#x27;, [
         &#x27;$animate&#x27;, &#x27;$sce&#x27;, &#x27;$compile&#x27;, &#x27;$templateRequest&#x27;,
function ($animate ,  $sce ,  $compile ,  $templateRequest) {
  return {
    link: function ( scope, elem, attrs ) {
      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

      var changeCounter = 0,
        currentScope,
        previousElement,
        currentElement;

      var cleanupLastIncludeContent = function() {
        if (previousElement) {
          previousElement.remove();
          previousElement = null;
        }
        if (currentScope) {
          currentScope.$destroy();
          currentScope = null;
        }
        if (currentElement) {
          $animate.leave(currentElement).then(function() {
            previousElement = null;
          });
          previousElement = currentElement;
          currentElement = null;
        }
      };

      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function (src) {
        var thisChangeId = ++changeCounter;

        if (src) {
          //set the 2nd param to true to ignore the template request error so that the inner
          //contents and scope can be cleaned up.
          $templateRequest(src, true).then(function(response) {
            if (thisChangeId !== changeCounter) { return; }
            var newScope = origScope.$new();
            var template = response;

            var clone = $compile(template)(newScope, function(clone) {
              cleanupLastIncludeContent();
              $animate.enter(clone, elem);
            });

            currentScope = newScope;
            currentElement = clone;

            currentScope.$emit(&#x27;$includeContentLoaded&#x27;, src);
          }, function() {
            if (thisChangeId === changeCounter) {
              cleanupLastIncludeContent();
              scope.$emit(&#x27;$includeContentError&#x27;, src);
            }
          });
          scope.$emit(&#x27;$includeContentRequested&#x27;, src);
        } else {
          cleanupLastIncludeContent();
        }
      });

      scope.$on(&#x27;$destroy&#x27;, cleanupLastIncludeContent);
    }
  };
}])

/**
 * Note that it&#x27;s intentional that these classes are *not* applied through $animate.
 * They must not be animated as they&#x27;re expected to be present on the tooltip on
 * initialization.
 */
.directive(&#x27;tooltipClasses&#x27;, function () {
  return {
    restrict: &#x27;A&#x27;,
    link: function (scope, element, attrs) {
      if (scope.placement) {
        element.addClass(scope.placement);
      }
      if (scope.popupClass) {
        element.addClass(scope.popupClass);
      }
      if (scope.animation()) {
        element.addClass(attrs.tooltipAnimationClass);
      }
    }
  };
})

.directive( &#x27;tooltipPopup&#x27;, function () {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { content: &#x27;@&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/tooltip/tooltip-popup.html&#x27;
  };
})

.directive( &#x27;tooltip&#x27;, [ &#x27;$tooltip&#x27;, function ( $tooltip ) {
  return $tooltip( &#x27;tooltip&#x27;, &#x27;tooltip&#x27;, &#x27;mouseenter&#x27; );
}])

.directive( &#x27;tooltipTemplatePopup&#x27;, function () {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { contentExp: &#x27;&amp;&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27;,
      originScope: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/tooltip/tooltip-template-popup.html&#x27;
  };
})

.directive( &#x27;tooltipTemplate&#x27;, [ &#x27;$tooltip&#x27;, function ( $tooltip ) {
  return $tooltip(&#x27;tooltipTemplate&#x27;, &#x27;tooltip&#x27;, &#x27;mouseenter&#x27;, {
    useContentExp: true
  });
}])

.directive( &#x27;tooltipHtmlPopup&#x27;, function () {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { contentExp: &#x27;&amp;&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/tooltip/tooltip-html-popup.html&#x27;
  };
})

.directive( &#x27;tooltipHtml&#x27;, [ &#x27;$tooltip&#x27;, function ( $tooltip ) {
  return $tooltip(&#x27;tooltipHtml&#x27;, &#x27;tooltip&#x27;, &#x27;mouseenter&#x27;, {
    useContentExp: true
  });
}])

/*
Deprecated
*/
.directive( &#x27;tooltipHtmlUnsafePopup&#x27;, function () {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { content: &#x27;@&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/tooltip/tooltip-html-unsafe-popup.html&#x27;
  };
})

.value(&#x27;tooltipHtmlUnsafeSuppressDeprecated&#x27;, false)
.directive( &#x27;tooltipHtmlUnsafe&#x27;, [
          &#x27;$tooltip&#x27;, &#x27;tooltipHtmlUnsafeSuppressDeprecated&#x27;, &#x27;$log&#x27;,
function ( $tooltip ,  tooltipHtmlUnsafeSuppressDeprecated ,  $log) {
  if (!tooltipHtmlUnsafeSuppressDeprecated) {
    $log.warn(&#x27;tooltip-html-unsafe is now deprecated. Use tooltip-html or tooltip-template instead.&#x27;);
  }
  return $tooltip( &#x27;tooltipHtmlUnsafe&#x27;, &#x27;tooltip&#x27;, &#x27;mouseenter&#x27; );
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html popovers, and selector delegatation.
 */
angular.module( &#x27;ui.bootstrap.popover&#x27;, [ &#x27;ui.bootstrap.tooltip&#x27; ] )

.directive( &#x27;popoverTemplatePopup&#x27;, function () {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { title: &#x27;@&#x27;, contentExp: &#x27;&amp;&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27;,
      originScope: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/popover/popover-template.html&#x27;
  };
})

.directive( &#x27;popoverTemplate&#x27;, [ &#x27;$tooltip&#x27;, function ( $tooltip ) {
  return $tooltip( &#x27;popoverTemplate&#x27;, &#x27;popover&#x27;, &#x27;click&#x27;, {
    useContentExp: true
  } );
}])

.directive( &#x27;popoverPopup&#x27;, function () {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { title: &#x27;@&#x27;, content: &#x27;@&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/popover/popover.html&#x27;
  };
})

.directive( &#x27;popover&#x27;, [ &#x27;$tooltip&#x27;, function ( $tooltip ) {
  return $tooltip( &#x27;popover&#x27;, &#x27;popover&#x27;, &#x27;click&#x27; );
}]);

angular.module(&#x27;ui.bootstrap.progressbar&#x27;, [])

.constant(&#x27;progressConfig&#x27;, {
  animate: true,
  max: 100
})

.controller(&#x27;ProgressController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;progressConfig&#x27;, function($scope, $attrs, progressConfig) {
    var self = this,
        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

    this.bars = [];
    $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;

    this.addBar = function(bar, element) {
        if ( !animate ) {
            element.css({&#x27;transition&#x27;: &#x27;none&#x27;});
        }

        this.bars.push(bar);

        bar.$watch(&#x27;value&#x27;, function( value ) {
            bar.percent = +(100 * value / $scope.max).toFixed(2);
        });

        bar.$on(&#x27;$destroy&#x27;, function() {
            element = null;
            self.removeBar(bar);
        });
    };

    this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
    };
}])

.directive(&#x27;progress&#x27;, function() {
    return {
        restrict: &#x27;EA&#x27;,
        replace: true,
        transclude: true,
        controller: &#x27;ProgressController&#x27;,
        require: &#x27;progress&#x27;,
        scope: {},
        templateUrl: &#x27;template/progressbar/progress.html&#x27;
    };
})

.directive(&#x27;bar&#x27;, function() {
    return {
        restrict: &#x27;EA&#x27;,
        replace: true,
        transclude: true,
        require: &#x27;^progress&#x27;,
        scope: {
            value: &#x27;=&#x27;,
            max: &#x27;=?&#x27;,
            type: &#x27;@&#x27;
        },
        templateUrl: &#x27;template/progressbar/bar.html&#x27;,
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element);
        }
    };
})

.directive(&#x27;progressbar&#x27;, function() {
    return {
        restrict: &#x27;EA&#x27;,
        replace: true,
        transclude: true,
        controller: &#x27;ProgressController&#x27;,
        scope: {
            value: &#x27;=&#x27;,
            max: &#x27;=?&#x27;,
            type: &#x27;@&#x27;
        },
        templateUrl: &#x27;template/progressbar/progressbar.html&#x27;,
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]));
        }
    };
});

angular.module(&#x27;ui.bootstrap.rating&#x27;, [])

.constant(&#x27;ratingConfig&#x27;, {
  max: 5,
  stateOn: null,
  stateOff: null
})

.controller(&#x27;RatingController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;ratingConfig&#x27;, function($scope, $attrs, ratingConfig) {
  var ngModelCtrl  = { $setViewValue: angular.noop };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.push(function(value) {
      if (angular.isNumber(value) &amp;&amp; value &lt;&lt; 0 !== value) {
        value = Math.round(value);
      }
      return value;
    });

    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;

    var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) :
                        new Array( angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max );
    $scope.range = this.buildTemplateObjects(ratingStates);
  };

  this.buildTemplateObjects = function(states) {
    for (var i = 0, n = states.length; i &lt; n; i++) {
      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff }, states[i]);
    }
    return states;
  };

  $scope.rate = function(value) {
    if ( !$scope.readonly &amp;&amp; value &gt;= 0 &amp;&amp; value &lt;= $scope.range.length ) {
      ngModelCtrl.$setViewValue(value);
      ngModelCtrl.$render();
    }
  };

  $scope.enter = function(value) {
    if ( !$scope.readonly ) {
      $scope.value = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.onLeave();
  };

  $scope.onKeydown = function(evt) {
    if (/(37|38|39|40)/.test(evt.which)) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.rate( $scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1) );
    }
  };

  this.render = function() {
    $scope.value = ngModelCtrl.$viewValue;
  };
}])

.directive(&#x27;rating&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    require: [&#x27;rating&#x27;, &#x27;ngModel&#x27;],
    scope: {
      readonly: &#x27;=?&#x27;,
      onHover: &#x27;&amp;&#x27;,
      onLeave: &#x27;&amp;&#x27;
    },
    controller: &#x27;RatingController&#x27;,
    templateUrl: &#x27;template/rating/rating.html&#x27;,
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      ratingCtrl.init( ngModelCtrl );
    }
  };
});

/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */

angular.module(&#x27;ui.bootstrap.tabs&#x27;, [])

.controller(&#x27;TabsetController&#x27;, [&#x27;$scope&#x27;, function TabsetCtrl($scope) {
  var ctrl = this,
      tabs = ctrl.tabs = $scope.tabs = [];

  ctrl.select = function(selectedTab) {
    angular.forEach(tabs, function(tab) {
      if (tab.active &amp;&amp; tab !== selectedTab) {
        tab.active = false;
        tab.onDeselect();
      }
    });
    selectedTab.active = true;
    selectedTab.onSelect();
  };

  ctrl.addTab = function addTab(tab) {
    tabs.push(tab);
    // we can&#x27;t run the select function on the first tab
    // since that would select it twice
    if (tabs.length === 1 &amp;&amp; tab.active !== false) {
      tab.active = true;
    } else if (tab.active) {
      ctrl.select(tab);
    }
    else {
      tab.active = false;
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index = tabs.indexOf(tab);
    //Select a new tab if the tab to be removed is selected and not destroyed
    if (tab.active &amp;&amp; tabs.length &gt; 1 &amp;&amp; !destroyed) {
      //If this is the last tab, select the previous tab. else, the next tab.
      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
      ctrl.select(tabs[newActiveIndex]);
    }
    tabs.splice(index, 1);
  };

  var destroyed;
  $scope.$on(&#x27;$destroy&#x27;, function() {
    destroyed = true;
  });
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabset
 * @restrict EA
 *
 * @description
 * Tabset is the outer container for the tabs directive
 *
 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
 *
 * @example
&lt;example module=&quot;ui.bootstrap&quot;&gt;
  &lt;file name=&quot;index.html&quot;&gt;
    &lt;tabset&gt;
      &lt;tab heading=&quot;Tab 1&quot;&gt;&lt;b&gt;First&lt;/b&gt; Content!&lt;/tab&gt;
      &lt;tab heading=&quot;Tab 2&quot;&gt;&lt;i&gt;Second&lt;/i&gt; Content!&lt;/tab&gt;
    &lt;/tabset&gt;
    &lt;hr /&gt;
    &lt;tabset vertical=&quot;true&quot;&gt;
      &lt;tab heading=&quot;Vertical Tab 1&quot;&gt;&lt;b&gt;First&lt;/b&gt; Vertical Content!&lt;/tab&gt;
      &lt;tab heading=&quot;Vertical Tab 2&quot;&gt;&lt;i&gt;Second&lt;/i&gt; Vertical Content!&lt;/tab&gt;
    &lt;/tabset&gt;
    &lt;tabset justified=&quot;true&quot;&gt;
      &lt;tab heading=&quot;Justified Tab 1&quot;&gt;&lt;b&gt;First&lt;/b&gt; Justified Content!&lt;/tab&gt;
      &lt;tab heading=&quot;Justified Tab 2&quot;&gt;&lt;i&gt;Second&lt;/i&gt; Justified Content!&lt;/tab&gt;
    &lt;/tabset&gt;
  &lt;/file&gt;
&lt;/example&gt;
 */
.directive(&#x27;tabset&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    transclude: true,
    replace: true,
    scope: {
      type: &#x27;@&#x27;
    },
    controller: &#x27;TabsetController&#x27;,
    templateUrl: &#x27;template/tabs/tabset.html&#x27;,
    link: function(scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
    }
  };
})

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tab
 * @restrict EA
 *
 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
 * @param {string=} select An expression to evaluate when the tab is selected.
 * @param {boolean=} active A binding, telling whether or not this tab is selected.
 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
 *
 * @description
 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
 *
 * @example
&lt;example module=&quot;ui.bootstrap&quot;&gt;
  &lt;file name=&quot;index.html&quot;&gt;
    &lt;div ng-controller=&quot;TabsDemoCtrl&quot;&gt;
      &lt;button class=&quot;btn btn-small&quot; ng-click=&quot;items[0].active = true&quot;&gt;
        Select item 1, using active binding
      &lt;/button&gt;
      &lt;button class=&quot;btn btn-small&quot; ng-click=&quot;items[1].disabled = !items[1].disabled&quot;&gt;
        Enable/disable item 2, using disabled binding
      &lt;/button&gt;
      &lt;br /&gt;
      &lt;tabset&gt;
        &lt;tab heading=&quot;Tab 1&quot;&gt;First Tab&lt;/tab&gt;
        &lt;tab select=&quot;alertMe()&quot;&gt;
          &lt;tab-heading&gt;&lt;i class=&quot;icon-bell&quot;&gt;&lt;/i&gt; Alert me!&lt;/tab-heading&gt;
          Second Tab, with alert callback and html heading!
        &lt;/tab&gt;
        &lt;tab ng-repeat=&quot;item in items&quot;
          heading=&quot;{{item.title}}&quot;
          disabled=&quot;item.disabled&quot;
          active=&quot;item.active&quot;&gt;
          {{item.content}}
        &lt;/tab&gt;
      &lt;/tabset&gt;
    &lt;/div&gt;
  &lt;/file&gt;
  &lt;file name=&quot;script.js&quot;&gt;
    function TabsDemoCtrl($scope) {
      $scope.items = [
        { title:&quot;Dynamic Title 1&quot;, content:&quot;Dynamic Item 0&quot; },
        { title:&quot;Dynamic Title 2&quot;, content:&quot;Dynamic Item 1&quot;, disabled: true }
      ];

      $scope.alertMe = function() {
        setTimeout(function() {
          alert(&quot;You&#x27;ve selected the alert tab!&quot;);
        });
      };
    };
  &lt;/file&gt;
&lt;/example&gt;
 */

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabHeading
 * @restrict EA
 *
 * @description
 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
 *
 * @example
&lt;example module=&quot;ui.bootstrap&quot;&gt;
  &lt;file name=&quot;index.html&quot;&gt;
    &lt;tabset&gt;
      &lt;tab&gt;
        &lt;tab-heading&gt;&lt;b&gt;HTML&lt;/b&gt; in my titles?!&lt;/tab-heading&gt;
        And some content, too!
      &lt;/tab&gt;
      &lt;tab&gt;
        &lt;tab-heading&gt;&lt;i class=&quot;icon-heart&quot;&gt;&lt;/i&gt; Icon heading?!?&lt;/tab-heading&gt;
        That&#x27;s right.
      &lt;/tab&gt;
    &lt;/tabset&gt;
  &lt;/file&gt;
&lt;/example&gt;
 */
.directive(&#x27;tab&#x27;, [&#x27;$parse&#x27;, &#x27;$log&#x27;, function($parse, $log) {
  return {
    require: &#x27;^tabset&#x27;,
    restrict: &#x27;EA&#x27;,
    replace: true,
    templateUrl: &#x27;template/tabs/tab.html&#x27;,
    transclude: true,
    scope: {
      active: &#x27;=?&#x27;,
      heading: &#x27;@&#x27;,
      onSelect: &#x27;&amp;select&#x27;, //This callback is called in contentHeadingTransclude
                          //once it inserts the tab&#x27;s content into the dom
      onDeselect: &#x27;&amp;deselect&#x27;
    },
    controller: function() {
      //Empty controller so other directives can require being &#x27;under&#x27; a tab
    },
    compile: function(elm, attrs, transclude) {
      return function postLink(scope, elm, attrs, tabsetCtrl) {
        scope.$watch(&#x27;active&#x27;, function(active) {
          if (active) {
            tabsetCtrl.select(scope);
          }
        });

        scope.disabled = false;
        if ( attrs.disable ) {
          scope.$parent.$watch($parse(attrs.disable), function(value) {
            scope.disabled = !! value;
          });
        }

        // Deprecation support of &quot;disabled&quot; parameter
        // fix(tab): IE9 disabled attr renders grey text on enabled tab #2677
        // This code is duplicated from the lines above to make it easy to remove once
        // the feature has been completely deprecated
        if ( attrs.disabled ) {
          $log.warn(&#x27;Use of &quot;disabled&quot; attribute has been deprecated, please use &quot;disable&quot;&#x27;);
          scope.$parent.$watch($parse(attrs.disabled), function(value) {
            scope.disabled = !! value;
          });
        }

        scope.select = function() {
          if ( !scope.disabled ) {
            scope.active = true;
          }
        };

        tabsetCtrl.addTab(scope);
        scope.$on(&#x27;$destroy&#x27;, function() {
          tabsetCtrl.removeTab(scope);
        });

        //We need to transclude later, once the content container is ready.
        //when this link happens, we&#x27;re inside a tab heading.
        scope.$transcludeFn = transclude;
      };
    }
  };
}])

.directive(&#x27;tabHeadingTransclude&#x27;, [function() {
  return {
    restrict: &#x27;A&#x27;,
    require: &#x27;^tab&#x27;,
    link: function(scope, elm, attrs, tabCtrl) {
      scope.$watch(&#x27;headingElement&#x27;, function updateHeadingElement(heading) {
        if (heading) {
          elm.html(&#x27;&#x27;);
          elm.append(heading);
        }
      });
    }
  };
}])

.directive(&#x27;tabContentTransclude&#x27;, function() {
  return {
    restrict: &#x27;A&#x27;,
    require: &#x27;^tabset&#x27;,
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.tabContentTransclude);

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude &#x27;em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };
  function isTabHeading(node) {
    return node.tagName &amp;&amp;  (
      node.hasAttribute(&#x27;tab-heading&#x27;) ||
      node.hasAttribute(&#x27;data-tab-heading&#x27;) ||
      node.tagName.toLowerCase() === &#x27;tab-heading&#x27; ||
      node.tagName.toLowerCase() === &#x27;data-tab-heading&#x27;
    );
  }
})

;

angular.module(&#x27;ui.bootstrap.timepicker&#x27;, [])

.constant(&#x27;timepickerConfig&#x27;, {
  hourStep: 1,
  minuteStep: 1,
  showMeridian: true,
  meridians: null,
  readonlyInput: false,
  mousewheel: true,
  arrowkeys: true
})

.controller(&#x27;TimepickerController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;$parse&#x27;, &#x27;$log&#x27;, &#x27;$locale&#x27;, &#x27;timepickerConfig&#x27;, function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
  var selected = new Date(),
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;

  this.init = function( ngModelCtrl_, inputs ) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.unshift(function (modelValue) {
      return modelValue ? new Date( modelValue ) : null;
    });

    var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1);

    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
    if ( mousewheel ) {
      this.setupMousewheelEvents( hoursInputEl, minutesInputEl );
    }

    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
    if (arrowkeys) {
      this.setupArrowkeyEvents( hoursInputEl, minutesInputEl );
    }

    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
    this.setupInputEvents( hoursInputEl, minutesInputEl );
  };

  var hourStep = timepickerConfig.hourStep;
  if ($attrs.hourStep) {
    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
      hourStep = parseInt(value, 10);
    });
  }

  var minuteStep = timepickerConfig.minuteStep;
  if ($attrs.minuteStep) {
    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
      minuteStep = parseInt(value, 10);
    });
  }

  // 12H / 24H mode
  $scope.showMeridian = timepickerConfig.showMeridian;
  if ($attrs.showMeridian) {
    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
      $scope.showMeridian = !!value;

      if ( ngModelCtrl.$error.time ) {
        // Evaluate from template
        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
        if (angular.isDefined( hours ) &amp;&amp; angular.isDefined( minutes )) {
          selected.setHours( hours );
          refresh();
        }
      } else {
        updateTemplate();
      }
    });
  }

  // Get $scope.hours in 24H mode if valid
  function getHoursFromTemplate ( ) {
    var hours = parseInt( $scope.hours, 10 );
    var valid = ( $scope.showMeridian ) ? (hours &gt; 0 &amp;&amp; hours &lt; 13) : (hours &gt;= 0 &amp;&amp; hours &lt; 24);
    if ( !valid ) {
      return undefined;
    }

    if ( $scope.showMeridian ) {
      if ( hours === 12 ) {
        hours = 0;
      }
      if ( $scope.meridian === meridians[1] ) {
        hours = hours + 12;
      }
    }
    return hours;
  }

  function getMinutesFromTemplate() {
    var minutes = parseInt($scope.minutes, 10);
    return ( minutes &gt;= 0 &amp;&amp; minutes &lt; 60 ) ? minutes : undefined;
  }

  function pad( value ) {
    return ( angular.isDefined(value) &amp;&amp; value.toString().length &lt; 2 ) ? &#x27;0&#x27; + value : value.toString();
  }

  // Respond on mousewheel spin
  this.setupMousewheelEvents = function( hoursInputEl, minutesInputEl ) {
    var isScrollingUp = function(e) {
      if (e.originalEvent) {
        e = e.originalEvent;
      }
      //pick correct delta variable depending on event
      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
      return (e.detail || delta &gt; 0);
    };

    hoursInputEl.bind(&#x27;mousewheel wheel&#x27;, function(e) {
      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementHours() : $scope.decrementHours() );
      e.preventDefault();
    });

    minutesInputEl.bind(&#x27;mousewheel wheel&#x27;, function(e) {
      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementMinutes() : $scope.decrementMinutes() );
      e.preventDefault();
    });

  };

  // Respond on up/down arrowkeys
  this.setupArrowkeyEvents = function( hoursInputEl, minutesInputEl ) {
    hoursInputEl.bind(&#x27;keydown&#x27;, function(e) {
      if ( e.which === 38 ) { // up
        e.preventDefault();
        $scope.incrementHours();
        $scope.$apply();
      }
      else if ( e.which === 40 ) { // down
        e.preventDefault();
        $scope.decrementHours();
        $scope.$apply();
      }
    });

    minutesInputEl.bind(&#x27;keydown&#x27;, function(e) {
      if ( e.which === 38 ) { // up
        e.preventDefault();
        $scope.incrementMinutes();
        $scope.$apply();
      }
      else if ( e.which === 40 ) { // down
        e.preventDefault();
        $scope.decrementMinutes();
        $scope.$apply();
      }
    });
  };

  this.setupInputEvents = function( hoursInputEl, minutesInputEl ) {
    if ( $scope.readonlyInput ) {
      $scope.updateHours = angular.noop;
      $scope.updateMinutes = angular.noop;
      return;
    }

    var invalidate = function(invalidHours, invalidMinutes) {
      ngModelCtrl.$setViewValue( null );
      ngModelCtrl.$setValidity(&#x27;time&#x27;, false);
      if (angular.isDefined(invalidHours)) {
        $scope.invalidHours = invalidHours;
      }
      if (angular.isDefined(invalidMinutes)) {
        $scope.invalidMinutes = invalidMinutes;
      }
    };

    $scope.updateHours = function() {
      var hours = getHoursFromTemplate();

      if ( angular.isDefined(hours) ) {
        selected.setHours( hours );
        refresh( &#x27;h&#x27; );
      } else {
        invalidate(true);
      }
    };

    hoursInputEl.bind(&#x27;blur&#x27;, function(e) {
      if ( !$scope.invalidHours &amp;&amp; $scope.hours &lt; 10) {
        $scope.$apply( function() {
          $scope.hours = pad( $scope.hours );
        });
      }
    });

    $scope.updateMinutes = function() {
      var minutes = getMinutesFromTemplate();

      if ( angular.isDefined(minutes) ) {
        selected.setMinutes( minutes );
        refresh( &#x27;m&#x27; );
      } else {
        invalidate(undefined, true);
      }
    };

    minutesInputEl.bind(&#x27;blur&#x27;, function(e) {
      if ( !$scope.invalidMinutes &amp;&amp; $scope.minutes &lt; 10 ) {
        $scope.$apply( function() {
          $scope.minutes = pad( $scope.minutes );
        });
      }
    });

  };

  this.render = function() {
    var date = ngModelCtrl.$viewValue;

    if ( isNaN(date) ) {
      ngModelCtrl.$setValidity(&#x27;time&#x27;, false);
      $log.error(&#x27;Timepicker directive: &quot;ng-model&quot; value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.&#x27;);
    } else {
      if ( date ) {
        selected = date;
      }
      makeValid();
      updateTemplate();
    }
  };

  // Call internally when we know that model is valid.
  function refresh( keyboardChange ) {
    makeValid();
    ngModelCtrl.$setViewValue( new Date(selected) );
    updateTemplate( keyboardChange );
  }

  function makeValid() {
    ngModelCtrl.$setValidity(&#x27;time&#x27;, true);
    $scope.invalidHours = false;
    $scope.invalidMinutes = false;
  }

  function updateTemplate( keyboardChange ) {
    var hours = selected.getHours(), minutes = selected.getMinutes();

    if ( $scope.showMeridian ) {
      hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12; // Convert 24 to 12 hour system
    }

    $scope.hours = keyboardChange === &#x27;h&#x27; ? hours : pad(hours);
    if (keyboardChange !== &#x27;m&#x27;) {
      $scope.minutes = pad(minutes);
    }
    $scope.meridian = selected.getHours() &lt; 12 ? meridians[0] : meridians[1];
  }

  function addMinutes( minutes ) {
    var dt = new Date( selected.getTime() + minutes * 60000 );
    selected.setHours( dt.getHours(), dt.getMinutes() );
    refresh();
  }

  $scope.incrementHours = function() {
    addMinutes( hourStep * 60 );
  };
  $scope.decrementHours = function() {
    addMinutes( - hourStep * 60 );
  };
  $scope.incrementMinutes = function() {
    addMinutes( minuteStep );
  };
  $scope.decrementMinutes = function() {
    addMinutes( - minuteStep );
  };
  $scope.toggleMeridian = function() {
    addMinutes( 12 * 60 * (( selected.getHours() &lt; 12 ) ? 1 : -1) );
  };
}])

.directive(&#x27;timepicker&#x27;, function () {
  return {
    restrict: &#x27;EA&#x27;,
    require: [&#x27;timepicker&#x27;, &#x27;?^ngModel&#x27;],
    controller:&#x27;TimepickerController&#x27;,
    replace: true,
    scope: {},
    templateUrl: &#x27;template/timepicker/timepicker.html&#x27;,
    link: function(scope, element, attrs, ctrls) {
      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if ( ngModelCtrl ) {
        timepickerCtrl.init( ngModelCtrl, element.find(&#x27;input&#x27;) );
      }
    }
  };
});

angular.module(&#x27;ui.bootstrap.transition&#x27;, [])

.value(&#x27;$transitionSuppressDeprecated&#x27;, false)
/**
 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
 * @param  {DOMElement} element  The DOMElement that will be animated.
 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
 *   - As a string, it represents the css class to be added to the element.
 *   - As an object, it represents a hash of style attributes to be applied to the element.
 *   - As a function, it represents a function to be called that will cause the transition to occur.
 * @return {Promise}  A promise that is resolved when the transition finishes.
 */
.factory(&#x27;$transition&#x27;, [
        &#x27;$q&#x27;, &#x27;$timeout&#x27;, &#x27;$rootScope&#x27;, &#x27;$log&#x27;, &#x27;$transitionSuppressDeprecated&#x27;,
function($q ,  $timeout ,  $rootScope ,  $log ,  $transitionSuppressDeprecated) {

  if (!$transitionSuppressDeprecated) {
    $log.warn(&#x27;$transition is now deprecated. Use $animate from ngAnimate instead.&#x27;);
  }

  var $transition = function(element, trigger, options) {
    options = options || {};
    var deferred = $q.defer();
    var endEventName = $transition[options.animation ? &#x27;animationEndEventName&#x27; : &#x27;transitionEndEventName&#x27;];

    var transitionEndHandler = function(event) {
      $rootScope.$apply(function() {
        element.unbind(endEventName, transitionEndHandler);
        deferred.resolve(element);
      });
    };

    if (endEventName) {
      element.bind(endEventName, transitionEndHandler);
    }

    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
    $timeout(function() {
      if ( angular.isString(trigger) ) {
        element.addClass(trigger);
      } else if ( angular.isFunction(trigger) ) {
        trigger(element);
      } else if ( angular.isObject(trigger) ) {
        element.css(trigger);
      }
      //If browser does not support transitions, instantly resolve
      if ( !endEventName ) {
        deferred.resolve(element);
      }
    });

    // Add our custom cancel function to the promise that is returned
    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
    // i.e. it will therefore never raise a transitionEnd event for that transition
    deferred.promise.cancel = function() {
      if ( endEventName ) {
        element.unbind(endEventName, transitionEndHandler);
      }
      deferred.reject(&#x27;Transition cancelled&#x27;);
    };

    return deferred.promise;
  };

  // Work out the name of the transitionEnd event
  var transElement = document.createElement(&#x27;trans&#x27;);
  var transitionEndEventNames = {
    &#x27;WebkitTransition&#x27;: &#x27;webkitTransitionEnd&#x27;,
    &#x27;MozTransition&#x27;: &#x27;transitionend&#x27;,
    &#x27;OTransition&#x27;: &#x27;oTransitionEnd&#x27;,
    &#x27;transition&#x27;: &#x27;transitionend&#x27;
  };
  var animationEndEventNames = {
    &#x27;WebkitTransition&#x27;: &#x27;webkitAnimationEnd&#x27;,
    &#x27;MozTransition&#x27;: &#x27;animationend&#x27;,
    &#x27;OTransition&#x27;: &#x27;oAnimationEnd&#x27;,
    &#x27;transition&#x27;: &#x27;animationend&#x27;
  };
  function findEndEventName(endEventNames) {
    for (var name in endEventNames){
      if (transElement.style[name] !== undefined) {
        return endEventNames[name];
      }
    }
  }
  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
  $transition.animationEndEventName = findEndEventName(animationEndEventNames);
  return $transition;
}]);

angular.module(&#x27;ui.bootstrap.typeahead&#x27;, [&#x27;ui.bootstrap.position&#x27;, &#x27;ui.bootstrap.bindHtml&#x27;])

/**
 * A helper service that can parse typeahead&#x27;s syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory(&#x27;typeaheadParser&#x27;, [&#x27;$parse&#x27;, function ($parse) {

  //                      00000111000000000000022200000000000000003333333333333330000000000044000
  var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;

  return {
    parse:function (input) {

      var match = input.match(TYPEAHEAD_REGEXP);
      if (!match) {
        throw new Error(
          &#x27;Expected typeahead specification in form of &quot;_modelValue_ (as _label_)? for _item_ in _collection_&quot;&#x27; +
            &#x27; but got &quot;&#x27; + input + &#x27;&quot;.&#x27;);
      }

      return {
        itemName:match[3],
        source:$parse(match[4]),
        viewMapper:$parse(match[2] || match[1]),
        modelMapper:$parse(match[1])
      };
    }
  };
}])

  .directive(&#x27;typeahead&#x27;, [&#x27;$compile&#x27;, &#x27;$parse&#x27;, &#x27;$q&#x27;, &#x27;$timeout&#x27;, &#x27;$document&#x27;, &#x27;$position&#x27;, &#x27;typeaheadParser&#x27;,
    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {

  var HOT_KEYS = [9, 13, 27, 38, 40];

  return {
    require:&#x27;ngModel&#x27;,
    link:function (originalScope, element, attrs, modelCtrl) {

      //SUPPORTED ATTRIBUTES (OPTIONS)

      //minimal no of characters that needs to be entered before typeahead kicks-in
      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;

      //minimal wait time after last character typed before typeahead kicks-in
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

      //should it restrict model values to the ones selected from the popup only?
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

      //binding to a variable that indicates if matches are being retrieved asynchronously
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

      //a callback executed when a match is selected
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);

      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

      var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

      var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

      //INTERNAL VARIABLES

      //model setter executed upon match selection
      var $setModelValue = $parse(attrs.ngModel).assign;

      //expressions used by typeahead
      var parserResult = typeaheadParser.parse(attrs.typeahead);

      var hasFocus;

      //create a child scope for the typeahead directive so we are not polluting original scope
      //with typeahead-specific data (matches, query etc.)
      var scope = originalScope.$new();
      originalScope.$on(&#x27;$destroy&#x27;, function(){
        scope.$destroy();
      });

      // WAI-ARIA
      var popupId = &#x27;typeahead-&#x27; + scope.$id + &#x27;-&#x27; + Math.floor(Math.random() * 10000);
      element.attr({
        &#x27;aria-autocomplete&#x27;: &#x27;list&#x27;,
        &#x27;aria-expanded&#x27;: false,
        &#x27;aria-owns&#x27;: popupId
      });

      //pop-up element used to display matches
      var popUpEl = angular.element(&#x27;&lt;div typeahead-popup&gt;&lt;/div&gt;&#x27;);
      popUpEl.attr({
        id: popupId,
        matches: &#x27;matches&#x27;,
        active: &#x27;activeIdx&#x27;,
        select: &#x27;select(activeIdx)&#x27;,
        query: &#x27;query&#x27;,
        position: &#x27;position&#x27;
      });
      //custom item template
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr(&#x27;template-url&#x27;, attrs.typeaheadTemplateUrl);
      }

      var resetMatches = function() {
        scope.matches = [];
        scope.activeIdx = -1;
        element.attr(&#x27;aria-expanded&#x27;, false);
      };

      var getMatchId = function(index) {
        return popupId + &#x27;-option-&#x27; + index;
      };

      // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
      // This attribute is added or removed automatically when the &#x60;activeIdx&#x60; changes.
      scope.$watch(&#x27;activeIdx&#x27;, function(index) {
        if (index &lt; 0) {
          element.removeAttr(&#x27;aria-activedescendant&#x27;);
        } else {
          element.attr(&#x27;aria-activedescendant&#x27;, getMatchId(index));
        }
      });

      var getMatchesAsync = function(inputValue) {

        var locals = {$viewValue: inputValue};
        isLoadingSetter(originalScope, true);
        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {

          //it might happen that several async queries were in progress if a user were typing fast
          //but we are interested only in responses that correspond to the current view value
          var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
          if (onCurrentRequest &amp;&amp; hasFocus) {
            if (matches &amp;&amp; matches.length &gt; 0) {

              scope.activeIdx = focusFirst ? 0 : -1;
              scope.matches.length = 0;

              //transform labels
              for(var i=0; i&lt;matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  id: getMatchId(i),
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }

              scope.query = inputValue;
              //position pop-up with matches - we need to re-calculate its position each time we are opening a window
              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
              //due to other elements being rendered
              scope.position = appendToBody ? $position.offset(element) : $position.position(element);
              scope.position.top = scope.position.top + element.prop(&#x27;offsetHeight&#x27;);

              element.attr(&#x27;aria-expanded&#x27;, true);
            } else {
              resetMatches();
            }
          }
          if (onCurrentRequest) {
            isLoadingSetter(originalScope, false);
          }
        }, function(){
          resetMatches();
          isLoadingSetter(originalScope, false);
        });
      };

      resetMatches();

      //we need to propagate user&#x27;s query so we can higlight matches
      scope.query = undefined;

      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
      var timeoutPromise;

      var scheduleSearchWithTimeout = function(inputValue) {
        timeoutPromise = $timeout(function () {
          getMatchesAsync(inputValue);
        }, waitTime);
      };

      var cancelPreviousTimeout = function() {
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
      };

      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
      modelCtrl.$parsers.unshift(function (inputValue) {

        hasFocus = true;

        if (inputValue &amp;&amp; inputValue.length &gt;= minSearch) {
          if (waitTime &gt; 0) {
            cancelPreviousTimeout();
            scheduleSearchWithTimeout(inputValue);
          } else {
            getMatchesAsync(inputValue);
          }
        } else {
          isLoadingSetter(originalScope, false);
          cancelPreviousTimeout();
          resetMatches();
        }

        if (isEditable) {
          return inputValue;
        } else {
          if (!inputValue) {
            // Reset in case user had typed something previously.
            modelCtrl.$setValidity(&#x27;editable&#x27;, true);
            return inputValue;
          } else {
            modelCtrl.$setValidity(&#x27;editable&#x27;, false);
            return undefined;
          }
        }
      });

      modelCtrl.$formatters.push(function (modelValue) {

        var candidateViewValue, emptyViewValue;
        var locals = {};

        // The validity may be set to false via $parsers (see above) if
        // the model is restricted to selected values. If the model
        // is set manually it is considered to be valid.
        if (!isEditable) {
          modelCtrl.$setValidity(&#x27;editable&#x27;, true);
        }

        if (inputFormatter) {

          locals.$model = modelValue;
          return inputFormatter(originalScope, locals);

        } else {

          //it might happen that we don&#x27;t have enough info to properly render input value
          //we need to check for this situation and simply return model value if we can&#x27;t apply custom formatting
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);

          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;
        }
      });

      scope.select = function (activeIdx) {
        //called from within the $digest() cycle
        var locals = {};
        var model, item;

        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity(&#x27;editable&#x27;, true);
        modelCtrl.$setValidity(&#x27;parse&#x27;, true);

        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals)
        });

        resetMatches();

        //return focus to the input element if a match was selected via a mouse click event
        // use timeout to avoid $rootScope:inprog error
        $timeout(function() { element[0].focus(); }, 0, false);
      };

      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
      element.bind(&#x27;keydown&#x27;, function (evt) {

        //typeahead is open and an &quot;interesting&quot; key was pressed
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }

        // if there&#x27;s nothing selected (i.e. focusFirst) and enter is hit, don&#x27;t do anything
        if (scope.activeIdx == -1 &amp;&amp; (evt.which === 13 || evt.which === 9)) {
          return;
        }

        evt.preventDefault();

        if (evt.which === 40) {
          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
          scope.$digest();

        } else if (evt.which === 38) {
          scope.activeIdx = (scope.activeIdx &gt; 0 ? scope.activeIdx : scope.matches.length) - 1;
          scope.$digest();

        } else if (evt.which === 13 || evt.which === 9) {
          scope.$apply(function () {
            scope.select(scope.activeIdx);
          });

        } else if (evt.which === 27) {
          evt.stopPropagation();

          resetMatches();
          scope.$digest();
        }
      });

      element.bind(&#x27;blur&#x27;, function (evt) {
        hasFocus = false;
      });

      // Keep reference to click handler to unbind it.
      var dismissClickHandler = function (evt) {
        if (element[0] !== evt.target) {
          resetMatches();
          scope.$digest();
        }
      };

      $document.bind(&#x27;click&#x27;, dismissClickHandler);

      originalScope.$on(&#x27;$destroy&#x27;, function(){
        $document.unbind(&#x27;click&#x27;, dismissClickHandler);
        if (appendToBody) {
          $popup.remove();
        }
        // Prevent jQuery cache memory leak
        popUpEl.remove();
      });

      var $popup = $compile(popUpEl)(scope);

      if (appendToBody) {
        $document.find(&#x27;body&#x27;).append($popup);
      } else {
        element.after($popup);
      }
    }
  };

}])

  .directive(&#x27;typeaheadPopup&#x27;, function () {
    return {
      restrict:&#x27;EA&#x27;,
      scope:{
        matches:&#x27;=&#x27;,
        query:&#x27;=&#x27;,
        active:&#x27;=&#x27;,
        position:&#x27;=&#x27;,
        select:&#x27;&amp;&#x27;
      },
      replace:true,
      templateUrl:&#x27;template/typeahead/typeahead-popup.html&#x27;,
      link:function (scope, element, attrs) {

        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function () {
          return scope.matches.length &gt; 0;
        };

        scope.isActive = function (matchIdx) {
          return scope.active == matchIdx;
        };

        scope.selectActive = function (matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function (activeIdx) {
          scope.select({activeIdx:activeIdx});
        };
      }
    };
  })

  .directive(&#x27;typeaheadMatch&#x27;, [&#x27;$templateRequest&#x27;, &#x27;$compile&#x27;, &#x27;$parse&#x27;, function ($templateRequest, $compile, $parse) {
    return {
      restrict:&#x27;EA&#x27;,
      scope:{
        index:&#x27;=&#x27;,
        match:&#x27;=&#x27;,
        query:&#x27;=&#x27;
      },
      link:function (scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || &#x27;template/typeahead/typeahead-match.html&#x27;;
        $templateRequest(tplUrl).then(function(tplContent) {
          $compile(tplContent.trim())(scope, function(clonedElement){
            element.replaceWith(clonedElement);
          });
        });
      }
    };
  }])

  .filter(&#x27;typeaheadHighlight&#x27;, function() {

    function escapeRegexp(queryToEscape) {
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, &#x27;\\$1&#x27;);
    }

    return function(matchItem, query) {
      return query ? (&#x27;&#x27; + matchItem).replace(new RegExp(escapeRegexp(query), &#x27;gi&#x27;), &#x27;&lt;strong&gt;$&amp;&lt;/strong&gt;&#x27;) : matchItem;
    };
  });

angular.module(&quot;template/accordion/accordion-group.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/accordion/accordion-group.html&quot;,
    &quot;&lt;div class=\&quot;panel panel-default\&quot;&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;panel-heading\&quot;&gt;\n&quot; +
    &quot;    &lt;h4 class=\&quot;panel-title\&quot;&gt;\n&quot; +
    &quot;      &lt;a href=\&quot;javascript:void(0)\&quot; tabindex=\&quot;0\&quot; class=\&quot;accordion-toggle\&quot; ng-click=\&quot;toggleOpen()\&quot; accordion-transclude=\&quot;heading\&quot;&gt;&lt;span ng-class=\&quot;{&#x27;text-muted&#x27;: isDisabled}\&quot;&gt;{{heading}}&lt;/span&gt;&lt;/a&gt;\n&quot; +
    &quot;    &lt;/h4&gt;\n&quot; +
    &quot;  &lt;/div&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;panel-collapse collapse\&quot; collapse=\&quot;!isOpen\&quot;&gt;\n&quot; +
    &quot;	  &lt;div class=\&quot;panel-body\&quot; ng-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;  &lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/accordion/accordion.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/accordion/accordion.html&quot;,
    &quot;&lt;div class=\&quot;panel-group\&quot; ng-transclude&gt;&lt;/div&gt;&quot;);
}]);

angular.module(&quot;template/alert/alert.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/alert/alert.html&quot;,
    &quot;&lt;div class=\&quot;alert\&quot; ng-class=\&quot;[&#x27;alert-&#x27; + (type || &#x27;warning&#x27;), closeable ? &#x27;alert-dismissable&#x27; : null]\&quot; role=\&quot;alert\&quot;&gt;\n&quot; +
    &quot;    &lt;button ng-show=\&quot;closeable\&quot; type=\&quot;button\&quot; class=\&quot;close\&quot; ng-click=\&quot;close()\&quot;&gt;\n&quot; +
    &quot;        &lt;span aria-hidden=\&quot;true\&quot;&gt;&amp;times;&lt;/span&gt;\n&quot; +
    &quot;        &lt;span class=\&quot;sr-only\&quot;&gt;Close&lt;/span&gt;\n&quot; +
    &quot;    &lt;/button&gt;\n&quot; +
    &quot;    &lt;div ng-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/carousel/carousel.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/carousel/carousel.html&quot;,
    &quot;&lt;div ng-mouseenter=\&quot;pause()\&quot; ng-mouseleave=\&quot;play()\&quot; class=\&quot;carousel\&quot; ng-swipe-right=\&quot;prev()\&quot; ng-swipe-left=\&quot;next()\&quot;&gt;\n&quot; +
    &quot;    &lt;ol class=\&quot;carousel-indicators\&quot; ng-show=\&quot;slides.length &gt; 1\&quot;&gt;\n&quot; +
    &quot;        &lt;li ng-repeat=\&quot;slide in slides | orderBy:&#x27;index&#x27; track by $index\&quot; ng-class=\&quot;{active: isActive(slide)}\&quot; ng-click=\&quot;select(slide)\&quot;&gt;&lt;/li&gt;\n&quot; +
    &quot;    &lt;/ol&gt;\n&quot; +
    &quot;    &lt;div class=\&quot;carousel-inner\&quot; ng-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;    &lt;a class=\&quot;left carousel-control\&quot; ng-click=\&quot;prev()\&quot; ng-show=\&quot;slides.length &gt; 1\&quot;&gt;&lt;span class=\&quot;glyphicon glyphicon-chevron-left\&quot;&gt;&lt;/span&gt;&lt;/a&gt;\n&quot; +
    &quot;    &lt;a class=\&quot;right carousel-control\&quot; ng-click=\&quot;next()\&quot; ng-show=\&quot;slides.length &gt; 1\&quot;&gt;&lt;span class=\&quot;glyphicon glyphicon-chevron-right\&quot;&gt;&lt;/span&gt;&lt;/a&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/carousel/slide.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/carousel/slide.html&quot;,
    &quot;&lt;div ng-class=\&quot;{\n&quot; +
    &quot;    &#x27;active&#x27;: active\n&quot; +
    &quot;  }\&quot; class=\&quot;item text-center\&quot; ng-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/datepicker/datepicker.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/datepicker/datepicker.html&quot;,
    &quot;&lt;div ng-switch=\&quot;datepickerMode\&quot; role=\&quot;application\&quot; ng-keydown=\&quot;keydown($event)\&quot;&gt;\n&quot; +
    &quot;  &lt;daypicker ng-switch-when=\&quot;day\&quot; tabindex=\&quot;0\&quot;&gt;&lt;/daypicker&gt;\n&quot; +
    &quot;  &lt;monthpicker ng-switch-when=\&quot;month\&quot; tabindex=\&quot;0\&quot;&gt;&lt;/monthpicker&gt;\n&quot; +
    &quot;  &lt;yearpicker ng-switch-when=\&quot;year\&quot; tabindex=\&quot;0\&quot;&gt;&lt;/yearpicker&gt;\n&quot; +
    &quot;&lt;/div&gt;&quot;);
}]);

angular.module(&quot;template/datepicker/day.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/datepicker/day.html&quot;,
    &quot;&lt;table role=\&quot;grid\&quot; aria-labelledby=\&quot;{{uniqueId}}-title\&quot; aria-activedescendant=\&quot;{{activeDateId}}\&quot;&gt;\n&quot; +
    &quot;  &lt;thead&gt;\n&quot; +
    &quot;    &lt;tr&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm pull-left\&quot; ng-click=\&quot;move(-1)\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;i class=\&quot;glyphicon glyphicon-chevron-left\&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th colspan=\&quot;{{5 + showWeeks}}\&quot;&gt;&lt;button id=\&quot;{{uniqueId}}-title\&quot; role=\&quot;heading\&quot; aria-live=\&quot;assertive\&quot; aria-atomic=\&quot;true\&quot; type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm\&quot; ng-click=\&quot;toggleMode()\&quot; ng-disabled=\&quot;datepickerMode === maxMode\&quot; tabindex=\&quot;-1\&quot; style=\&quot;width:100%;\&quot;&gt;&lt;strong&gt;{{title}}&lt;/strong&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm pull-right\&quot; ng-click=\&quot;move(1)\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;i class=\&quot;glyphicon glyphicon-chevron-right\&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;    &lt;tr&gt;\n&quot; +
    &quot;      &lt;th ng-show=\&quot;showWeeks\&quot; class=\&quot;text-center\&quot;&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th ng-repeat=\&quot;label in labels track by $index\&quot; class=\&quot;text-center\&quot;&gt;&lt;small aria-label=\&quot;{{label.full}}\&quot;&gt;{{label.abbr}}&lt;/small&gt;&lt;/th&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/thead&gt;\n&quot; +
    &quot;  &lt;tbody&gt;\n&quot; +
    &quot;    &lt;tr ng-repeat=\&quot;row in rows track by $index\&quot;&gt;\n&quot; +
    &quot;      &lt;td ng-show=\&quot;showWeeks\&quot; class=\&quot;text-center h6\&quot;&gt;&lt;em&gt;{{ weekNumbers[$index] }}&lt;/em&gt;&lt;/td&gt;\n&quot; +
    &quot;      &lt;td ng-repeat=\&quot;dt in row track by dt.date\&quot; class=\&quot;text-center\&quot; role=\&quot;gridcell\&quot; id=\&quot;{{dt.uid}}\&quot; aria-disabled=\&quot;{{!!dt.disabled}}\&quot; ng-class=\&quot;dt.customClass\&quot;&gt;\n&quot; +
    &quot;        &lt;button type=\&quot;button\&quot; style=\&quot;width:100%;\&quot; class=\&quot;btn btn-default btn-sm\&quot; ng-class=\&quot;{&#x27;btn-info&#x27;: dt.selected, active: isActive(dt)}\&quot; ng-click=\&quot;select(dt.date)\&quot; ng-disabled=\&quot;dt.disabled\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;span ng-class=\&quot;{&#x27;text-muted&#x27;: dt.secondary, &#x27;text-info&#x27;: dt.current}\&quot;&gt;{{dt.label}}&lt;/span&gt;&lt;/button&gt;\n&quot; +
    &quot;      &lt;/td&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/tbody&gt;\n&quot; +
    &quot;&lt;/table&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/datepicker/month.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/datepicker/month.html&quot;,
    &quot;&lt;table role=\&quot;grid\&quot; aria-labelledby=\&quot;{{uniqueId}}-title\&quot; aria-activedescendant=\&quot;{{activeDateId}}\&quot;&gt;\n&quot; +
    &quot;  &lt;thead&gt;\n&quot; +
    &quot;    &lt;tr&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm pull-left\&quot; ng-click=\&quot;move(-1)\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;i class=\&quot;glyphicon glyphicon-chevron-left\&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button id=\&quot;{{uniqueId}}-title\&quot; role=\&quot;heading\&quot; aria-live=\&quot;assertive\&quot; aria-atomic=\&quot;true\&quot; type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm\&quot; ng-click=\&quot;toggleMode()\&quot; ng-disabled=\&quot;datepickerMode === maxMode\&quot; tabindex=\&quot;-1\&quot; style=\&quot;width:100%;\&quot;&gt;&lt;strong&gt;{{title}}&lt;/strong&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm pull-right\&quot; ng-click=\&quot;move(1)\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;i class=\&quot;glyphicon glyphicon-chevron-right\&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/thead&gt;\n&quot; +
    &quot;  &lt;tbody&gt;\n&quot; +
    &quot;    &lt;tr ng-repeat=\&quot;row in rows track by $index\&quot;&gt;\n&quot; +
    &quot;      &lt;td ng-repeat=\&quot;dt in row track by dt.date\&quot; class=\&quot;text-center\&quot; role=\&quot;gridcell\&quot; id=\&quot;{{dt.uid}}\&quot; aria-disabled=\&quot;{{!!dt.disabled}}\&quot;&gt;\n&quot; +
    &quot;        &lt;button type=\&quot;button\&quot; style=\&quot;width:100%;\&quot; class=\&quot;btn btn-default\&quot; ng-class=\&quot;{&#x27;btn-info&#x27;: dt.selected, active: isActive(dt)}\&quot; ng-click=\&quot;select(dt.date)\&quot; ng-disabled=\&quot;dt.disabled\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;span ng-class=\&quot;{&#x27;text-info&#x27;: dt.current}\&quot;&gt;{{dt.label}}&lt;/span&gt;&lt;/button&gt;\n&quot; +
    &quot;      &lt;/td&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/tbody&gt;\n&quot; +
    &quot;&lt;/table&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/datepicker/popup.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/datepicker/popup.html&quot;,
    &quot;&lt;ul class=\&quot;dropdown-menu\&quot; ng-style=\&quot;{display: (isOpen &amp;&amp; &#x27;block&#x27;) || &#x27;none&#x27;, top: position.top+&#x27;px&#x27;, left: position.left+&#x27;px&#x27;}\&quot; ng-keydown=\&quot;keydown($event)\&quot;&gt;\n&quot; +
    &quot;	&lt;li ng-transclude&gt;&lt;/li&gt;\n&quot; +
    &quot;	&lt;li ng-if=\&quot;showButtonBar\&quot; style=\&quot;padding:10px 9px 2px\&quot;&gt;\n&quot; +
    &quot;		&lt;span class=\&quot;btn-group pull-left\&quot;&gt;\n&quot; +
    &quot;			&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-sm btn-info\&quot; ng-click=\&quot;select(&#x27;today&#x27;)\&quot;&gt;{{ getText(&#x27;current&#x27;) }}&lt;/button&gt;\n&quot; +
    &quot;			&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-sm btn-danger\&quot; ng-click=\&quot;select(null)\&quot;&gt;{{ getText(&#x27;clear&#x27;) }}&lt;/button&gt;\n&quot; +
    &quot;		&lt;/span&gt;\n&quot; +
    &quot;		&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-sm btn-success pull-right\&quot; ng-click=\&quot;close()\&quot;&gt;{{ getText(&#x27;close&#x27;) }}&lt;/button&gt;\n&quot; +
    &quot;	&lt;/li&gt;\n&quot; +
    &quot;&lt;/ul&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/datepicker/year.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/datepicker/year.html&quot;,
    &quot;&lt;table role=\&quot;grid\&quot; aria-labelledby=\&quot;{{uniqueId}}-title\&quot; aria-activedescendant=\&quot;{{activeDateId}}\&quot;&gt;\n&quot; +
    &quot;  &lt;thead&gt;\n&quot; +
    &quot;    &lt;tr&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm pull-left\&quot; ng-click=\&quot;move(-1)\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;i class=\&quot;glyphicon glyphicon-chevron-left\&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th colspan=\&quot;3\&quot;&gt;&lt;button id=\&quot;{{uniqueId}}-title\&quot; role=\&quot;heading\&quot; aria-live=\&quot;assertive\&quot; aria-atomic=\&quot;true\&quot; type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm\&quot; ng-click=\&quot;toggleMode()\&quot; ng-disabled=\&quot;datepickerMode === maxMode\&quot; tabindex=\&quot;-1\&quot; style=\&quot;width:100%;\&quot;&gt;&lt;strong&gt;{{title}}&lt;/strong&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;      &lt;th&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default btn-sm pull-right\&quot; ng-click=\&quot;move(1)\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;i class=\&quot;glyphicon glyphicon-chevron-right\&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/thead&gt;\n&quot; +
    &quot;  &lt;tbody&gt;\n&quot; +
    &quot;    &lt;tr ng-repeat=\&quot;row in rows track by $index\&quot;&gt;\n&quot; +
    &quot;      &lt;td ng-repeat=\&quot;dt in row track by dt.date\&quot; class=\&quot;text-center\&quot; role=\&quot;gridcell\&quot; id=\&quot;{{dt.uid}}\&quot; aria-disabled=\&quot;{{!!dt.disabled}}\&quot;&gt;\n&quot; +
    &quot;        &lt;button type=\&quot;button\&quot; style=\&quot;width:100%;\&quot; class=\&quot;btn btn-default\&quot; ng-class=\&quot;{&#x27;btn-info&#x27;: dt.selected, active: isActive(dt)}\&quot; ng-click=\&quot;select(dt.date)\&quot; ng-disabled=\&quot;dt.disabled\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;span ng-class=\&quot;{&#x27;text-info&#x27;: dt.current}\&quot;&gt;{{dt.label}}&lt;/span&gt;&lt;/button&gt;\n&quot; +
    &quot;      &lt;/td&gt;\n&quot; +
    &quot;    &lt;/tr&gt;\n&quot; +
    &quot;  &lt;/tbody&gt;\n&quot; +
    &quot;&lt;/table&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/modal/backdrop.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/modal/backdrop.html&quot;,
    &quot;&lt;div class=\&quot;modal-backdrop\&quot;\n&quot; +
    &quot;     modal-animation-class=\&quot;fade\&quot;\n&quot; +
    &quot;     ng-class=\&quot;{in: animate}\&quot;\n&quot; +
    &quot;     ng-style=\&quot;{&#x27;z-index&#x27;: 1040 + (index &amp;&amp; 1 || 0) + index*10}\&quot;\n&quot; +
    &quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/modal/window.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/modal/window.html&quot;,
    &quot;&lt;div modal-render=\&quot;{{$isRendered}}\&quot; tabindex=\&quot;-1\&quot; role=\&quot;dialog\&quot; class=\&quot;modal\&quot;\n&quot; +
    &quot;    modal-animation-class=\&quot;fade\&quot;\n&quot; +
    &quot;	ng-class=\&quot;{in: animate}\&quot; ng-style=\&quot;{&#x27;z-index&#x27;: 1050 + index*10, display: &#x27;block&#x27;}\&quot; ng-click=\&quot;close($event)\&quot;&gt;\n&quot; +
    &quot;    &lt;div class=\&quot;modal-dialog\&quot; ng-class=\&quot;size ? &#x27;modal-&#x27; + size : &#x27;&#x27;\&quot;&gt;&lt;div class=\&quot;modal-content\&quot; modal-transclude&gt;&lt;/div&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/pagination/pager.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/pagination/pager.html&quot;,
    &quot;&lt;ul class=\&quot;pager\&quot;&gt;\n&quot; +
    &quot;  &lt;li ng-class=\&quot;{disabled: noPrevious(), previous: align}\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(page - 1, $event)\&quot;&gt;{{getText(&#x27;previous&#x27;)}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;  &lt;li ng-class=\&quot;{disabled: noNext(), next: align}\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(page + 1, $event)\&quot;&gt;{{getText(&#x27;next&#x27;)}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;&lt;/ul&gt;&quot;);
}]);

angular.module(&quot;template/pagination/pagination.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/pagination/pagination.html&quot;,
    &quot;&lt;ul class=\&quot;pagination\&quot;&gt;\n&quot; +
    &quot;  &lt;li ng-if=\&quot;boundaryLinks\&quot; ng-class=\&quot;{disabled: noPrevious()}\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(1, $event)\&quot;&gt;{{getText(&#x27;first&#x27;)}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;  &lt;li ng-if=\&quot;directionLinks\&quot; ng-class=\&quot;{disabled: noPrevious()}\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(page - 1, $event)\&quot;&gt;{{getText(&#x27;previous&#x27;)}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;  &lt;li ng-repeat=\&quot;page in pages track by $index\&quot; ng-class=\&quot;{active: page.active}\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(page.number, $event)\&quot;&gt;{{page.text}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;  &lt;li ng-if=\&quot;directionLinks\&quot; ng-class=\&quot;{disabled: noNext()}\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(page + 1, $event)\&quot;&gt;{{getText(&#x27;next&#x27;)}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;  &lt;li ng-if=\&quot;boundaryLinks\&quot; ng-class=\&quot;{disabled: noNext()}\&quot;&gt;&lt;a href ng-click=\&quot;selectPage(totalPages, $event)\&quot;&gt;{{getText(&#x27;last&#x27;)}}&lt;/a&gt;&lt;/li&gt;\n&quot; +
    &quot;&lt;/ul&gt;&quot;);
}]);

angular.module(&quot;template/tooltip/tooltip-html-popup.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/tooltip/tooltip-html-popup.html&quot;,
    &quot;&lt;div class=\&quot;tooltip\&quot;\n&quot; +
    &quot;  tooltip-animation-class=\&quot;fade\&quot;\n&quot; +
    &quot;  tooltip-classes\n&quot; +
    &quot;  ng-class=\&quot;{ in: isOpen() }\&quot;&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;tooltip-arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;tooltip-inner\&quot; ng-bind-html=\&quot;contentExp()\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/tooltip/tooltip-html-unsafe-popup.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/tooltip/tooltip-html-unsafe-popup.html&quot;,
    &quot;&lt;div class=\&quot;tooltip\&quot;\n&quot; +
    &quot;  tooltip-animation-class=\&quot;fade\&quot;\n&quot; +
    &quot;  tooltip-classes\n&quot; +
    &quot;  ng-class=\&quot;{ in: isOpen() }\&quot;&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;tooltip-arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;tooltip-inner\&quot; bind-html-unsafe=\&quot;content\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/tooltip/tooltip-popup.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/tooltip/tooltip-popup.html&quot;,
    &quot;&lt;div class=\&quot;tooltip\&quot;\n&quot; +
    &quot;  tooltip-animation-class=\&quot;fade\&quot;\n&quot; +
    &quot;  tooltip-classes\n&quot; +
    &quot;  ng-class=\&quot;{ in: isOpen() }\&quot;&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;tooltip-arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;tooltip-inner\&quot; ng-bind=\&quot;content\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/tooltip/tooltip-template-popup.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/tooltip/tooltip-template-popup.html&quot;,
    &quot;&lt;div class=\&quot;tooltip\&quot;\n&quot; +
    &quot;  tooltip-animation-class=\&quot;fade\&quot;\n&quot; +
    &quot;  tooltip-classes\n&quot; +
    &quot;  ng-class=\&quot;{ in: isOpen() }\&quot;&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;tooltip-arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;tooltip-inner\&quot;\n&quot; +
    &quot;    tooltip-template-transclude=\&quot;contentExp()\&quot;\n&quot; +
    &quot;    tooltip-template-transclude-scope=\&quot;originScope()\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/popover/popover-template.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/popover/popover-template.html&quot;,
    &quot;&lt;div class=\&quot;popover\&quot;\n&quot; +
    &quot;  tooltip-animation-class=\&quot;fade\&quot;\n&quot; +
    &quot;  tooltip-classes\n&quot; +
    &quot;  ng-class=\&quot;{ in: isOpen() }\&quot;&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;\n&quot; +
    &quot;  &lt;div class=\&quot;popover-inner\&quot;&gt;\n&quot; +
    &quot;      &lt;h3 class=\&quot;popover-title\&quot; ng-bind=\&quot;title\&quot; ng-if=\&quot;title\&quot;&gt;&lt;/h3&gt;\n&quot; +
    &quot;      &lt;div class=\&quot;popover-content\&quot;\n&quot; +
    &quot;        tooltip-template-transclude=\&quot;contentExp()\&quot;\n&quot; +
    &quot;        tooltip-template-transclude-scope=\&quot;originScope()\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;  &lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/popover/popover-window.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/popover/popover-window.html&quot;,
    &quot;&lt;div class=\&quot;popover {{placement}}\&quot; ng-class=\&quot;{ in: isOpen, fade: animation }\&quot;&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;\n&quot; +
    &quot;  &lt;div class=\&quot;popover-inner\&quot;&gt;\n&quot; +
    &quot;      &lt;h3 class=\&quot;popover-title\&quot; ng-bind=\&quot;title\&quot; ng-show=\&quot;title\&quot;&gt;&lt;/h3&gt;\n&quot; +
    &quot;      &lt;div class=\&quot;popover-content\&quot; tooltip-template-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;  &lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/popover/popover.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/popover/popover.html&quot;,
    &quot;&lt;div class=\&quot;popover\&quot;\n&quot; +
    &quot;  tooltip-animation-class=\&quot;fade\&quot;\n&quot; +
    &quot;  tooltip-classes\n&quot; +
    &quot;  ng-class=\&quot;{ in: isOpen() }\&quot;&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;arrow\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;\n&quot; +
    &quot;  &lt;div class=\&quot;popover-inner\&quot;&gt;\n&quot; +
    &quot;      &lt;h3 class=\&quot;popover-title\&quot; ng-bind=\&quot;title\&quot; ng-if=\&quot;title\&quot;&gt;&lt;/h3&gt;\n&quot; +
    &quot;      &lt;div class=\&quot;popover-content\&quot; ng-bind=\&quot;content\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;  &lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/progressbar/bar.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/progressbar/bar.html&quot;,
    &quot;&lt;div class=\&quot;progress-bar\&quot; ng-class=\&quot;type &amp;&amp; &#x27;progress-bar-&#x27; + type\&quot; role=\&quot;progressbar\&quot; aria-valuenow=\&quot;{{value}}\&quot; aria-valuemin=\&quot;0\&quot; aria-valuemax=\&quot;{{max}}\&quot; ng-style=\&quot;{width: (percent &lt; 100 ? percent : 100) + &#x27;%&#x27;}\&quot; aria-valuetext=\&quot;{{percent | number:0}}%\&quot; ng-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/progressbar/progress.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/progressbar/progress.html&quot;,
    &quot;&lt;div class=\&quot;progress\&quot; ng-transclude&gt;&lt;/div&gt;&quot;);
}]);

angular.module(&quot;template/progressbar/progressbar.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/progressbar/progressbar.html&quot;,
    &quot;&lt;div class=\&quot;progress\&quot;&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;progress-bar\&quot; ng-class=\&quot;type &amp;&amp; &#x27;progress-bar-&#x27; + type\&quot; role=\&quot;progressbar\&quot; aria-valuenow=\&quot;{{value}}\&quot; aria-valuemin=\&quot;0\&quot; aria-valuemax=\&quot;{{max}}\&quot; ng-style=\&quot;{width: (percent &lt; 100 ? percent : 100) + &#x27;%&#x27;}\&quot; aria-valuetext=\&quot;{{percent | number:0}}%\&quot; ng-transclude&gt;&lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/rating/rating.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/rating/rating.html&quot;,
    &quot;&lt;span ng-mouseleave=\&quot;reset()\&quot; ng-keydown=\&quot;onKeydown($event)\&quot; tabindex=\&quot;0\&quot; role=\&quot;slider\&quot; aria-valuemin=\&quot;0\&quot; aria-valuemax=\&quot;{{range.length}}\&quot; aria-valuenow=\&quot;{{value}}\&quot;&gt;\n&quot; +
    &quot;    &lt;i ng-repeat=\&quot;r in range track by $index\&quot; ng-mouseenter=\&quot;enter($index + 1)\&quot; ng-click=\&quot;rate($index + 1)\&quot; class=\&quot;glyphicon\&quot; ng-class=\&quot;$index &lt; value &amp;&amp; (r.stateOn || &#x27;glyphicon-star&#x27;) || (r.stateOff || &#x27;glyphicon-star-empty&#x27;)\&quot;&gt;\n&quot; +
    &quot;        &lt;span class=\&quot;sr-only\&quot;&gt;({{ $index &lt; value ? &#x27;*&#x27; : &#x27; &#x27; }})&lt;/span&gt;\n&quot; +
    &quot;    &lt;/i&gt;\n&quot; +
    &quot;&lt;/span&gt;&quot;);
}]);

angular.module(&quot;template/tabs/tab.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/tabs/tab.html&quot;,
    &quot;&lt;li ng-class=\&quot;{active: active, disabled: disabled}\&quot;&gt;\n&quot; +
    &quot;  &lt;a href ng-click=\&quot;select()\&quot; tab-heading-transclude&gt;{{heading}}&lt;/a&gt;\n&quot; +
    &quot;&lt;/li&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/tabs/tabset.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/tabs/tabset.html&quot;,
    &quot;&lt;div&gt;\n&quot; +
    &quot;  &lt;ul class=\&quot;nav nav-{{type || &#x27;tabs&#x27;}}\&quot; ng-class=\&quot;{&#x27;nav-stacked&#x27;: vertical, &#x27;nav-justified&#x27;: justified}\&quot; ng-transclude&gt;&lt;/ul&gt;\n&quot; +
    &quot;  &lt;div class=\&quot;tab-content\&quot;&gt;\n&quot; +
    &quot;    &lt;div class=\&quot;tab-pane\&quot; \n&quot; +
    &quot;         ng-repeat=\&quot;tab in tabs\&quot; \n&quot; +
    &quot;         ng-class=\&quot;{active: tab.active}\&quot;\n&quot; +
    &quot;         tab-content-transclude=\&quot;tab\&quot;&gt;\n&quot; +
    &quot;    &lt;/div&gt;\n&quot; +
    &quot;  &lt;/div&gt;\n&quot; +
    &quot;&lt;/div&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/timepicker/timepicker.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/timepicker/timepicker.html&quot;,
    &quot;&lt;table&gt;\n&quot; +
    &quot;	&lt;tbody&gt;\n&quot; +
    &quot;		&lt;tr class=\&quot;text-center\&quot;&gt;\n&quot; +
    &quot;			&lt;td&gt;&lt;a ng-click=\&quot;incrementHours()\&quot; class=\&quot;btn btn-link\&quot;&gt;&lt;span class=\&quot;glyphicon glyphicon-chevron-up\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n&quot; +
    &quot;			&lt;td&gt;&amp;nbsp;&lt;/td&gt;\n&quot; +
    &quot;			&lt;td&gt;&lt;a ng-click=\&quot;incrementMinutes()\&quot; class=\&quot;btn btn-link\&quot;&gt;&lt;span class=\&quot;glyphicon glyphicon-chevron-up\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n&quot; +
    &quot;			&lt;td ng-show=\&quot;showMeridian\&quot;&gt;&lt;/td&gt;\n&quot; +
    &quot;		&lt;/tr&gt;\n&quot; +
    &quot;		&lt;tr&gt;\n&quot; +
    &quot;			&lt;td class=\&quot;form-group\&quot; ng-class=\&quot;{&#x27;has-error&#x27;: invalidHours}\&quot;&gt;\n&quot; +
    &quot;				&lt;input style=\&quot;width:50px;\&quot; type=\&quot;text\&quot; ng-model=\&quot;hours\&quot; ng-change=\&quot;updateHours()\&quot; class=\&quot;form-control text-center\&quot; ng-readonly=\&quot;readonlyInput\&quot; maxlength=\&quot;2\&quot;&gt;\n&quot; +
    &quot;			&lt;/td&gt;\n&quot; +
    &quot;			&lt;td&gt;:&lt;/td&gt;\n&quot; +
    &quot;			&lt;td class=\&quot;form-group\&quot; ng-class=\&quot;{&#x27;has-error&#x27;: invalidMinutes}\&quot;&gt;\n&quot; +
    &quot;				&lt;input style=\&quot;width:50px;\&quot; type=\&quot;text\&quot; ng-model=\&quot;minutes\&quot; ng-change=\&quot;updateMinutes()\&quot; class=\&quot;form-control text-center\&quot; ng-readonly=\&quot;readonlyInput\&quot; maxlength=\&quot;2\&quot;&gt;\n&quot; +
    &quot;			&lt;/td&gt;\n&quot; +
    &quot;			&lt;td ng-show=\&quot;showMeridian\&quot;&gt;&lt;button type=\&quot;button\&quot; class=\&quot;btn btn-default text-center\&quot; ng-click=\&quot;toggleMeridian()\&quot;&gt;{{meridian}}&lt;/button&gt;&lt;/td&gt;\n&quot; +
    &quot;		&lt;/tr&gt;\n&quot; +
    &quot;		&lt;tr class=\&quot;text-center\&quot;&gt;\n&quot; +
    &quot;			&lt;td&gt;&lt;a ng-click=\&quot;decrementHours()\&quot; class=\&quot;btn btn-link\&quot;&gt;&lt;span class=\&quot;glyphicon glyphicon-chevron-down\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n&quot; +
    &quot;			&lt;td&gt;&amp;nbsp;&lt;/td&gt;\n&quot; +
    &quot;			&lt;td&gt;&lt;a ng-click=\&quot;decrementMinutes()\&quot; class=\&quot;btn btn-link\&quot;&gt;&lt;span class=\&quot;glyphicon glyphicon-chevron-down\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n&quot; +
    &quot;			&lt;td ng-show=\&quot;showMeridian\&quot;&gt;&lt;/td&gt;\n&quot; +
    &quot;		&lt;/tr&gt;\n&quot; +
    &quot;	&lt;/tbody&gt;\n&quot; +
    &quot;&lt;/table&gt;\n&quot; +
    &quot;&quot;);
}]);

angular.module(&quot;template/typeahead/typeahead-match.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/typeahead/typeahead-match.html&quot;,
    &quot;&lt;a tabindex=\&quot;-1\&quot; bind-html-unsafe=\&quot;match.label | typeaheadHighlight:query\&quot;&gt;&lt;/a&gt;&quot;);
}]);

angular.module(&quot;template/typeahead/typeahead-popup.html&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {
  $templateCache.put(&quot;template/typeahead/typeahead-popup.html&quot;,
    &quot;&lt;ul class=\&quot;dropdown-menu\&quot; ng-show=\&quot;isOpen()\&quot; ng-style=\&quot;{top: position.top+&#x27;px&#x27;, left: position.left+&#x27;px&#x27;}\&quot; style=\&quot;display: block;\&quot; role=\&quot;listbox\&quot; aria-hidden=\&quot;{{!isOpen()}}\&quot;&gt;\n&quot; +
    &quot;    &lt;li ng-repeat=\&quot;match in matches track by $index\&quot; ng-class=\&quot;{active: isActive($index) }\&quot; ng-mouseenter=\&quot;selectActive($index)\&quot; ng-click=\&quot;selectMatch($index)\&quot; role=\&quot;option\&quot; id=\&quot;{{match.id}}\&quot;&gt;\n&quot; +
    &quot;        &lt;div typeahead-match index=\&quot;$index\&quot; match=\&quot;match\&quot; query=\&quot;query\&quot; template-url=\&quot;templateUrl\&quot;&gt;&lt;/div&gt;\n&quot; +
    &quot;    &lt;/li&gt;\n&quot; +
    &quot;&lt;/ul&gt;\n&quot; +
    &quot;&quot;);
}]);
!angular.$$csp() &amp;&amp; angular.element(document).find(&#x27;head&#x27;).prepend(&#x27;&lt;style type=&quot;text/css&quot;&gt;.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}&lt;/style&gt;&#x27;);
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
