<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>client/lib/angular-ui-router/src/state.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/classroom.html">classroom</a></li>
                                <li><a href="../classes/classroom.attendance.html">classroom.attendance</a></li>
                                <li><a href="../classes/classroom.AttendanceService.html">classroom.AttendanceService</a></li>
                                <li><a href="../classes/classroom.AuthFactory.html">classroom.AuthFactory</a></li>
                                <li><a href="../classes/classroom.grades.html">classroom.grades</a></li>
                                <li><a href="../classes/classroom.GradeService.html">classroom.GradeService</a></li>
                                <li><a href="../classes/classroom.LessonService.html">classroom.LessonService</a></li>
                                <li><a href="../classes/classroom.login.html">classroom.login</a></li>
                                <li><a href="../classes/classroom.signup.html">classroom.signup</a></li>
                                <li><a href="../classes/classroom.syllabus.html">classroom.syllabus</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/ng.html">ng</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: client/lib/angular-ui-router/src/state.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @ngdoc object
 * @name ui.router.state.$stateProvider
 *
 * @requires ui.router.router.$urlRouterProvider
 * @requires ui.router.util.$urlMatcherFactoryProvider
 *
 * @description
 * The new &#x60;$stateProvider&#x60; works similar to Angular&#x27;s v1 router, but it focuses purely
 * on state.
 *
 * A state corresponds to a &quot;place&quot; in the application in terms of the overall UI and
 * navigation. A state describes (via the controller / template / view properties) what
 * the UI looks like and does at that place.
 *
 * States often have things in common, and the primary way of factoring out these
 * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
 * nested states.
 *
 * The &#x60;$stateProvider&#x60; provides interfaces to declare these states for your app.
 */
$StateProvider.$inject = [&#x27;$urlRouterProvider&#x27;, &#x27;$urlMatcherFactoryProvider&#x27;];
function $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {

  var root, states = {}, $state, queue = {}, abstractKey = &#x27;abstract&#x27;;

  // Builds state properties from definition passed to registerState()
  var stateBuilder = {

    // Derive parent state from a hierarchical name only if &#x27;parent&#x27; is not explicitly defined.
    // state.children = [];
    // if (parent) parent.children.push(state);
    parent: function(state) {
      if (isDefined(state.parent) &amp;&amp; state.parent) return findState(state.parent);
      // regex matches any valid composite state name
      // would match &quot;contact.list&quot; but not &quot;contacts&quot;
      var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
      return compositeName ? findState(compositeName[1]) : root;
    },

    // inherit &#x27;data&#x27; from parent and override by own values (if any)
    data: function(state) {
      if (state.parent &amp;&amp; state.parent.data) {
        state.data = state.self.data = extend({}, state.parent.data, state.data);
      }
      return state.data;
    },

    // Build a URLMatcher if necessary, either via a relative or absolute URL
    url: function(state) {
      var url = state.url, config = { params: state.params || {} };

      if (isString(url)) {
        if (url.charAt(0) == &#x27;^&#x27;) return $urlMatcherFactory.compile(url.substring(1), config);
        return (state.parent.navigable || root).url.concat(url, config);
      }

      if (!url || $urlMatcherFactory.isMatcher(url)) return url;
      throw new Error(&quot;Invalid url &#x27;&quot; + url + &quot;&#x27; in state &#x27;&quot; + state + &quot;&#x27;&quot;);
    },

    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
    navigable: function(state) {
      return state.url ? state : (state.parent ? state.parent.navigable : null);
    },

    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params
    ownParams: function(state) {
      var params = state.url &amp;&amp; state.url.params || new $$UMFP.ParamSet();
      forEach(state.params || {}, function(config, id) {
        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, &quot;config&quot;);
      });
      return params;
    },

    // Derive parameters for this state and ensure they&#x27;re a super-set of parent&#x27;s parameters
    params: function(state) {
      return state.parent &amp;&amp; state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
    },

    // If there is no explicit multi-view configuration, make one up so we don&#x27;t have
    // to handle both cases in the view directive later. Note that having an explicit
    // &#x27;views&#x27; property will mean the default unnamed view properties are ignored. This
    // is also a good time to resolve view names to absolute names, so everything is a
    // straight lookup at link time.
    views: function(state) {
      var views = {};

      forEach(isDefined(state.views) ? state.views : { &#x27;&#x27;: state }, function (view, name) {
        if (name.indexOf(&#x27;@&#x27;) &lt; 0) name += &#x27;@&#x27; + state.parent.name;
        views[name] = view;
      });
      return views;
    },

    // Keep a full path from the root down to this state as this is needed for state activation.
    path: function(state) {
      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path
    },

    // Speed up $state.contains() as it&#x27;s used a lot
    includes: function(state) {
      var includes = state.parent ? extend({}, state.parent.includes) : {};
      includes[state.name] = true;
      return includes;
    },

    $delegates: {}
  };

  function isRelative(stateName) {
    return stateName.indexOf(&quot;.&quot;) === 0 || stateName.indexOf(&quot;^&quot;) === 0;
  }

  function findState(stateOrName, base) {
    if (!stateOrName) return undefined;

    var isStr = isString(stateOrName),
        name  = isStr ? stateOrName : stateOrName.name,
        path  = isRelative(name);

    if (path) {
      if (!base) throw new Error(&quot;No reference point given for path &#x27;&quot;  + name + &quot;&#x27;&quot;);
      base = findState(base);
      
      var rel = name.split(&quot;.&quot;), i = 0, pathLength = rel.length, current = base;

      for (; i &lt; pathLength; i++) {
        if (rel[i] === &quot;&quot; &amp;&amp; i === 0) {
          current = base;
          continue;
        }
        if (rel[i] === &quot;^&quot;) {
          if (!current.parent) throw new Error(&quot;Path &#x27;&quot; + name + &quot;&#x27; not valid for state &#x27;&quot; + base.name + &quot;&#x27;&quot;);
          current = current.parent;
          continue;
        }
        break;
      }
      rel = rel.slice(i).join(&quot;.&quot;);
      name = current.name + (current.name &amp;&amp; rel ? &quot;.&quot; : &quot;&quot;) + rel;
    }
    var state = states[name];

    if (state &amp;&amp; (isStr || (!isStr &amp;&amp; (state === stateOrName || state.self === stateOrName)))) {
      return state;
    }
    return undefined;
  }

  function queueState(parentName, state) {
    if (!queue[parentName]) {
      queue[parentName] = [];
    }
    queue[parentName].push(state);
  }

  function flushQueuedChildren(parentName) {
    var queued = queue[parentName] || [];
    while(queued.length) {
      registerState(queued.shift());
    }
  }

  function registerState(state) {
    // Wrap a new object around the state so we can store our private details easily.
    state = inherit(state, {
      self: state,
      resolve: state.resolve || {},
      toString: function() { return this.name; }
    });

    var name = state.name;
    if (!isString(name) || name.indexOf(&#x27;@&#x27;) &gt;= 0) throw new Error(&quot;State must have a valid name&quot;);
    if (states.hasOwnProperty(name)) throw new Error(&quot;State &#x27;&quot; + name + &quot;&#x27;&#x27; is already defined&quot;);

    // Get parent name
    var parentName = (name.indexOf(&#x27;.&#x27;) !== -1) ? name.substring(0, name.lastIndexOf(&#x27;.&#x27;))
        : (isString(state.parent)) ? state.parent
        : (isObject(state.parent) &amp;&amp; isString(state.parent.name)) ? state.parent.name
        : &#x27;&#x27;;

    // If parent is not registered yet, add state to queue and register later
    if (parentName &amp;&amp; !states[parentName]) {
      return queueState(parentName, state.self);
    }

    for (var key in stateBuilder) {
      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
    }
    states[name] = state;

    // Register the state in the global state list and with $urlRouter if necessary.
    if (!state[abstractKey] &amp;&amp; state.url) {
      $urlRouterProvider.when(state.url, [&#x27;$match&#x27;, &#x27;$stateParams&#x27;, function ($match, $stateParams) {
        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
          $state.transitionTo(state, $match, { inherit: true, location: false });
        }
      }]);
    }

    // Register any queued children
    flushQueuedChildren(name);

    return state;
  }

  // Checks text to see if it looks like a glob.
  function isGlob (text) {
    return text.indexOf(&#x27;*&#x27;) &gt; -1;
  }

  // Returns true if glob matches current $state name.
  function doesStateMatchGlob (glob) {
    var globSegments = glob.split(&#x27;.&#x27;),
        segments = $state.$current.name.split(&#x27;.&#x27;);

    //match single stars
    for (var i = 0, l = globSegments.length; i &lt; l; i++) {
      if (globSegments[i] === &#x27;*&#x27;) {
        segments[i] = &#x27;*&#x27;;
      }
    }

    //match greedy starts
    if (globSegments[0] === &#x27;**&#x27;) {
       segments = segments.slice(indexOf(segments, globSegments[1]));
       segments.unshift(&#x27;**&#x27;);
    }
    //match greedy ends
    if (globSegments[globSegments.length - 1] === &#x27;**&#x27;) {
       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
       segments.push(&#x27;**&#x27;);
    }

    if (globSegments.length != segments.length) {
      return false;
    }

    return segments.join(&#x27;&#x27;) === globSegments.join(&#x27;&#x27;);
  }


  // Implicit root state that is always active
  root = registerState({
    name: &#x27;&#x27;,
    url: &#x27;^&#x27;,
    views: null,
    &#x27;abstract&#x27;: true
  });
  root.navigable = null;


  /**
   * @ngdoc function
   * @name ui.router.state.$stateProvider#decorator
   * @methodOf ui.router.state.$stateProvider
   *
   * @description
   * Allows you to extend (carefully) or override (at your own peril) the 
   * &#x60;stateBuilder&#x60; object used internally by &#x60;$stateProvider&#x60;. This can be used 
   * to add custom functionality to ui-router, for example inferring templateUrl 
   * based on the state name.
   *
   * When passing only a name, it returns the current (original or decorated) builder
   * function that matches &#x60;name&#x60;.
   *
   * The builder functions that can be decorated are listed below. Though not all
   * necessarily have a good use case for decoration, that is up to you to decide.
   *
   * In addition, users can attach custom decorators, which will generate new 
   * properties within the state&#x27;s internal definition. There is currently no clear 
   * use-case for this beyond accessing internal states (i.e. $state.$current), 
   * however, expect this to become increasingly relevant as we introduce additional 
   * meta-programming features.
   *
   * **Warning**: Decorators should not be interdependent because the order of 
   * execution of the builder functions in non-deterministic. Builder functions 
   * should only be dependent on the state definition object and super function.
   *
   *
   * Existing builder functions and current return values:
   *
   * - **parent** &#x60;{object}&#x60; - returns the parent state object.
   * - **data** &#x60;{object}&#x60; - returns state data, including any inherited data that is not
   *   overridden by own values (if any).
   * - **url** &#x60;{object}&#x60; - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
   *   or &#x60;null&#x60;.
   * - **navigable** &#x60;{object}&#x60; - returns closest ancestor state that has a URL (aka is 
   *   navigable).
   * - **params** &#x60;{object}&#x60; - returns an array of state params that are ensured to 
   *   be a super-set of parent&#x27;s params.
   * - **views** &#x60;{object}&#x60; - returns a views object where each key is an absolute view 
   *   name (i.e. &quot;viewName@stateName&quot;) and each value is the config object 
   *   (template, controller) for the view. Even when you don&#x27;t use the views object 
   *   explicitly on a state config, one is still created for you internally.
   *   So by decorating this builder function you have access to decorating template 
   *   and controller properties.
   * - **ownParams** &#x60;{object}&#x60; - returns an array of params that belong to the state, 
   *   not including any params defined by ancestor states.
   * - **path** &#x60;{string}&#x60; - returns the full path from the root down to this state. 
   *   Needed for state activation.
   * - **includes** &#x60;{object}&#x60; - returns an object that includes every state that 
   *   would pass a &#x60;$state.includes()&#x60; test.
   *
   * @example
   * &lt;pre&gt;
   * // Override the internal &#x27;views&#x27; builder with a function that takes the state
   * // definition, and a reference to the internal function being overridden:
   * $stateProvider.decorator(&#x27;views&#x27;, function (state, parent) {
   *   var result = {},
   *       views = parent(state);
   *
   *   angular.forEach(views, function (config, name) {
   *     var autoName = (state.name + &#x27;.&#x27; + name).replace(&#x27;.&#x27;, &#x27;/&#x27;);
   *     config.templateUrl = config.templateUrl || &#x27;/partials/&#x27; + autoName + &#x27;.html&#x27;;
   *     result[name] = config;
   *   });
   *   return result;
   * });
   *
   * $stateProvider.state(&#x27;home&#x27;, {
   *   views: {
   *     &#x27;contact.list&#x27;: { controller: &#x27;ListController&#x27; },
   *     &#x27;contact.item&#x27;: { controller: &#x27;ItemController&#x27; }
   *   }
   * });
   *
   * // ...
   *
   * $state.go(&#x27;home&#x27;);
   * // Auto-populates list and item views with /partials/home/contact/list.html,
   * // and /partials/home/contact/item.html, respectively.
   * &lt;/pre&gt;
   *
   * @param {string} name The name of the builder function to decorate. 
   * @param {object} func A function that is responsible for decorating the original 
   * builder function. The function receives two parameters:
   *
   *   - &#x60;{object}&#x60; - state - The state config object.
   *   - &#x60;{object}&#x60; - super - The original builder function.
   *
   * @return {object} $stateProvider - $stateProvider instance
   */
  this.decorator = decorator;
  function decorator(name, func) {
    /*jshint validthis: true */
    if (isString(name) &amp;&amp; !isDefined(func)) {
      return stateBuilder[name];
    }
    if (!isFunction(func) || !isString(name)) {
      return this;
    }
    if (stateBuilder[name] &amp;&amp; !stateBuilder.$delegates[name]) {
      stateBuilder.$delegates[name] = stateBuilder[name];
    }
    stateBuilder[name] = func;
    return this;
  }

  /**
   * @ngdoc function
   * @name ui.router.state.$stateProvider#state
   * @methodOf ui.router.state.$stateProvider
   *
   * @description
   * Registers a state configuration under a given state name. The stateConfig object
   * has the following acceptable properties.
   *
   * @param {string} name A unique state name, e.g. &quot;home&quot;, &quot;about&quot;, &quot;contacts&quot;.
   * To create a parent/child state use a dot, e.g. &quot;about.sales&quot;, &quot;home.newest&quot;.
   * @param {object} stateConfig State configuration object.
   * @param {string|function=} stateConfig.template
   * &lt;a id=&#x27;template&#x27;&gt;&lt;/a&gt;
   *   html template as a string or a function that returns
   *   an html template as a string which should be used by the uiView directives. This property 
   *   takes precedence over templateUrl.
   *   
   *   If &#x60;template&#x60; is a function, it will be called with the following parameters:
   *
   *   - {array.&amp;lt;object&amp;gt;} - state parameters extracted from the current $location.path() by
   *     applying the current state
   *
   * &lt;pre&gt;template:
   *   &quot;&lt;h1&gt;inline template definition&lt;/h1&gt;&quot; +
   *   &quot;&lt;div ui-view&gt;&lt;/div&gt;&quot;&lt;/pre&gt;
   * &lt;pre&gt;template: function(params) {
   *       return &quot;&lt;h1&gt;generated template&lt;/h1&gt;&quot;; }&lt;/pre&gt;
   * &lt;/div&gt;
   *
   * @param {string|function=} stateConfig.templateUrl
   * &lt;a id=&#x27;templateUrl&#x27;&gt;&lt;/a&gt;
   *
   *   path or function that returns a path to an html
   *   template that should be used by uiView.
   *   
   *   If &#x60;templateUrl&#x60; is a function, it will be called with the following parameters:
   *
   *   - {array.&amp;lt;object&amp;gt;} - state parameters extracted from the current $location.path() by 
   *     applying the current state
   *
   * &lt;pre&gt;templateUrl: &quot;home.html&quot;&lt;/pre&gt;
   * &lt;pre&gt;templateUrl: function(params) {
   *     return myTemplates[params.pageId]; }&lt;/pre&gt;
   *
   * @param {function=} stateConfig.templateProvider
   * &lt;a id=&#x27;templateProvider&#x27;&gt;&lt;/a&gt;
   *    Provider function that returns HTML content string.
   * &lt;pre&gt; templateProvider:
   *       function(MyTemplateService, params) {
   *         return MyTemplateService.getTemplate(params.pageId);
   *       }&lt;/pre&gt;
   *
   * @param {string|function=} stateConfig.controller
   * &lt;a id=&#x27;controller&#x27;&gt;&lt;/a&gt;
   *
   *  Controller fn that should be associated with newly
   *   related scope or the name of a registered controller if passed as a string.
   *   Optionally, the ControllerAs may be declared here.
   * &lt;pre&gt;controller: &quot;MyRegisteredController&quot;&lt;/pre&gt;
   * &lt;pre&gt;controller:
   *     &quot;MyRegisteredController as fooCtrl&quot;}&lt;/pre&gt;
   * &lt;pre&gt;controller: function($scope, MyService) {
   *     $scope.data = MyService.getData(); }&lt;/pre&gt;
   *
   * @param {function=} stateConfig.controllerProvider
   * &lt;a id=&#x27;controllerProvider&#x27;&gt;&lt;/a&gt;
   *
   * Injectable provider function that returns the actual controller or string.
   * &lt;pre&gt;controllerProvider:
   *   function(MyResolveData) {
   *     if (MyResolveData.foo)
   *       return &quot;FooCtrl&quot;
   *     else if (MyResolveData.bar)
   *       return &quot;BarCtrl&quot;;
   *     else return function($scope) {
   *       $scope.baz = &quot;Qux&quot;;
   *     }
   *   }&lt;/pre&gt;
   *
   * @param {string=} stateConfig.controllerAs
   * &lt;a id=&#x27;controllerAs&#x27;&gt;&lt;/a&gt;
   * 
   * A controller alias name. If present the controller will be
   *   published to scope under the controllerAs name.
   * &lt;pre&gt;controllerAs: &quot;myCtrl&quot;&lt;/pre&gt;
   *
   * @param {string|object=} stateConfig.parent
   * &lt;a id=&#x27;parent&#x27;&gt;&lt;/a&gt;
   * Optionally specifies the parent state of this state.
   *
   * &lt;pre&gt;parent: &#x27;parentState&#x27;&lt;/pre&gt;
   * &lt;pre&gt;parent: parentState // JS variable&lt;/pre&gt;
   *
   * @param {object=} stateConfig.resolve
   * &lt;a id=&#x27;resolve&#x27;&gt;&lt;/a&gt;
   *
   * An optional map&amp;lt;string, function&amp;gt; of dependencies which
   *   should be injected into the controller. If any of these dependencies are promises, 
   *   the router will wait for them all to be resolved before the controller is instantiated.
   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired
   *   and the values of the resolved promises are injected into any controllers that reference them.
   *   If any  of the promises are rejected the $stateChangeError event is fired.
   *
   *   The map object is:
   *   
   *   - key - {string}: name of dependency to be injected into controller
   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, 
   *     it is injected and return value it treated as dependency. If result is a promise, it is 
   *     resolved before its value is injected into controller.
   *
   * &lt;pre&gt;resolve: {
   *     myResolve1:
   *       function($http, $stateParams) {
   *         return $http.get(&quot;/api/foos/&quot;+stateParams.fooID);
   *       }
   *     }&lt;/pre&gt;
   *
   * @param {string=} stateConfig.url
   * &lt;a id=&#x27;url&#x27;&gt;&lt;/a&gt;
   *
   *   A url fragment with optional parameters. When a state is navigated or
   *   transitioned to, the &#x60;$stateParams&#x60; service will be populated with any 
   *   parameters that were passed.
   *
   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} &#x60;UrlMatcher&#x60;} for
   *   more details on acceptable patterns )
   *
   * examples:
   * &lt;pre&gt;url: &quot;/home&quot;
   * url: &quot;/users/:userid&quot;
   * url: &quot;/books/{bookid:[a-zA-Z_-]}&quot;
   * url: &quot;/books/{categoryid:int}&quot;
   * url: &quot;/books/{publishername:string}/{categoryid:int}&quot;
   * url: &quot;/messages?before&amp;after&quot;
   * url: &quot;/messages?{before:date}&amp;{after:date}&quot;
   * url: &quot;/messages/:mailboxid?{before:date}&amp;{after:date}&quot;
   * &lt;/pre&gt;
   *
   * @param {object=} stateConfig.views
   * &lt;a id=&#x27;views&#x27;&gt;&lt;/a&gt;
   * an optional map&amp;lt;string, object&amp;gt; which defined multiple views, or targets views
   * manually/explicitly.
   *
   * Examples:
   *
   * Targets three named &#x60;ui-view&#x60;s in the parent state&#x27;s template
   * &lt;pre&gt;views: {
   *     header: {
   *       controller: &quot;headerCtrl&quot;,
   *       templateUrl: &quot;header.html&quot;
   *     }, body: {
   *       controller: &quot;bodyCtrl&quot;,
   *       templateUrl: &quot;body.html&quot;
   *     }, footer: {
   *       controller: &quot;footCtrl&quot;,
   *       templateUrl: &quot;footer.html&quot;
   *     }
   *   }&lt;/pre&gt;
   *
   * Targets named &#x60;ui-view=&quot;header&quot;&#x60; from grandparent state &#x27;top&#x27;&#x27;s template, and named &#x60;ui-view=&quot;body&quot; from parent state&#x27;s template.
   * &lt;pre&gt;views: {
   *     &#x27;header@top&#x27;: {
   *       controller: &quot;msgHeaderCtrl&quot;,
   *       templateUrl: &quot;msgHeader.html&quot;
   *     }, &#x27;body&#x27;: {
   *       controller: &quot;messagesCtrl&quot;,
   *       templateUrl: &quot;messages.html&quot;
   *     }
   *   }&lt;/pre&gt;
   *
   * @param {boolean=} [stateConfig.abstract=false]
   * &lt;a id=&#x27;abstract&#x27;&gt;&lt;/a&gt;
   * An abstract state will never be directly activated,
   *   but can provide inherited properties to its common children states.
   * &lt;pre&gt;abstract: true&lt;/pre&gt;
   *
   * @param {function=} stateConfig.onEnter
   * &lt;a id=&#x27;onEnter&#x27;&gt;&lt;/a&gt;
   *
   * Callback function for when a state is entered. Good way
   *   to trigger an action or dispatch an event, such as opening a dialog.
   * If minifying your scripts, make sure to explictly annotate this function,
   * because it won&#x27;t be automatically annotated by your build tools.
   *
   * &lt;pre&gt;onEnter: function(MyService, $stateParams) {
   *     MyService.foo($stateParams.myParam);
   * }&lt;/pre&gt;
   *
   * @param {function=} stateConfig.onExit
   * &lt;a id=&#x27;onExit&#x27;&gt;&lt;/a&gt;
   *
   * Callback function for when a state is exited. Good way to
   *   trigger an action or dispatch an event, such as opening a dialog.
   * If minifying your scripts, make sure to explictly annotate this function,
   * because it won&#x27;t be automatically annotated by your build tools.
   *
   * &lt;pre&gt;onExit: function(MyService, $stateParams) {
   *     MyService.cleanup($stateParams.myParam);
   * }&lt;/pre&gt;
   *
   * @param {boolean=} [stateConfig.reloadOnSearch=true]
   * &lt;a id=&#x27;reloadOnSearch&#x27;&gt;&lt;/a&gt;
   *
   * If &#x60;false&#x60;, will not retrigger the same state
   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). 
   *   Useful for when you&#x27;d like to modify $location.search() without triggering a reload.
   * &lt;pre&gt;reloadOnSearch: false&lt;/pre&gt;
   *
   * @param {object=} stateConfig.data
   * &lt;a id=&#x27;data&#x27;&gt;&lt;/a&gt;
   *
   * Arbitrary data object, useful for custom configuration.  The parent state&#x27;s &#x60;data&#x60; is
   *   prototypally inherited.  In other words, adding a data property to a state adds it to
   *   the entire subtree via prototypal inheritance.
   *
   * &lt;pre&gt;data: {
   *     requiredRole: &#x27;foo&#x27;
   * } &lt;/pre&gt;
   *
   * @param {object=} stateConfig.params
   * &lt;a id=&#x27;params&#x27;&gt;&lt;/a&gt;
   *
   * A map which optionally configures parameters declared in the &#x60;url&#x60;, or
   *   defines additional non-url parameters.  For each parameter being
   *   configured, add a configuration object keyed to the name of the parameter.
   *
   *   Each parameter configuration object may contain the following properties:
   *
   *   - ** value ** - {object|function=}: specifies the default value for this
   *     parameter.  This implicitly sets this parameter as optional.
   *
   *     When UI-Router routes to a state and no value is
   *     specified for this parameter in the URL or transition, the
   *     default value will be used instead.  If &#x60;value&#x60; is a function,
   *     it will be injected and invoked, and the return value used.
   *
   *     *Note*: &#x60;undefined&#x60; is treated as &quot;no default value&quot; while &#x60;null&#x60;
   *     is treated as &quot;the default value is &#x60;null&#x60;&quot;.
   *
   *     *Shorthand*: If you only need to configure the default value of the
   *     parameter, you may use a shorthand syntax.   In the **&#x60;params&#x60;**
   *     map, instead mapping the param name to a full parameter configuration
   *     object, simply set map it to the default parameter value, e.g.:
   *
   * &lt;pre&gt;// define a parameter&#x27;s default value
   * params: {
   *     param1: { value: &quot;defaultValue&quot; }
   * }
   * // shorthand default values
   * params: {
   *     param1: &quot;defaultValue&quot;,
   *     param2: &quot;param2Default&quot;
   * }&lt;/pre&gt;
   *
   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be
   *     treated as an array of values.  If you specified a Type, the value will be
   *     treated as an array of the specified Type.  Note: query parameter values
   *     default to a special &#x60;&quot;auto&quot;&#x60; mode.
   *
   *     For query parameters in &#x60;&quot;auto&quot;&#x60; mode, if multiple  values for a single parameter
   *     are present in the URL (e.g.: &#x60;/foo?bar=1&amp;bar=2&amp;bar=3&#x60;) then the values
   *     are mapped to an array (e.g.: &#x60;{ foo: [ &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27; ] }&#x60;).  However, if
   *     only one value is present (e.g.: &#x60;/foo?bar=1&#x60;) then the value is treated as single
   *     value (e.g.: &#x60;{ foo: &#x27;1&#x27; }&#x60;).
   *
   * &lt;pre&gt;params: {
   *     param1: { array: true }
   * }&lt;/pre&gt;
   *
   *   - ** squash ** - {bool|string=}: &#x60;squash&#x60; configures how a default parameter value is represented in the URL when
   *     the current parameter value is the same as the default value. If &#x60;squash&#x60; is not set, it uses the
   *     configured default squash policy.
   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy &#x60;defaultSquashPolicy()&#x60;})
   *
   *   There are three squash settings:
   *
   *     - false: The parameter&#x27;s default value is not squashed.  It is encoded and included in the URL
   *     - true: The parameter&#x27;s default value is omitted from the URL.  If the parameter is preceeded and followed
   *       by slashes in the state&#x27;s &#x60;url&#x60; declaration, then one of those slashes are omitted.
   *       This can allow for cleaner looking URLs.
   *     - &#x60;&quot;&lt;arbitrary string&gt;&quot;&#x60;: The parameter&#x27;s default value is replaced with an arbitrary placeholder of  your choice.
   *
   * &lt;pre&gt;params: {
   *     param1: {
   *       value: &quot;defaultId&quot;,
   *       squash: true
   * } }
   * // squash &quot;defaultValue&quot; to &quot;~&quot;
   * params: {
   *     param1: {
   *       value: &quot;defaultValue&quot;,
   *       squash: &quot;~&quot;
   * } }
   * &lt;/pre&gt;
   *
   *
   * @example
   * &lt;pre&gt;
   * // Some state name examples
   *
   * // stateName can be a single top-level name (must be unique).
   * $stateProvider.state(&quot;home&quot;, {});
   *
   * // Or it can be a nested state name. This state is a child of the
   * // above &quot;home&quot; state.
   * $stateProvider.state(&quot;home.newest&quot;, {});
   *
   * // Nest states as deeply as needed.
   * $stateProvider.state(&quot;home.newest.abc.xyz.inception&quot;, {});
   *
   * // state() returns $stateProvider, so you can chain state declarations.
   * $stateProvider
   *   .state(&quot;home&quot;, {})
   *   .state(&quot;about&quot;, {})
   *   .state(&quot;contacts&quot;, {});
   * &lt;/pre&gt;
   *
   */
  this.state = state;
  function state(name, definition) {
    /*jshint validthis: true */
    if (isObject(name)) definition = name;
    else definition.name = name;
    registerState(definition);
    return this;
  }

  /**
   * @ngdoc object
   * @name ui.router.state.$state
   *
   * @requires $rootScope
   * @requires $q
   * @requires ui.router.state.$view
   * @requires $injector
   * @requires ui.router.util.$resolve
   * @requires ui.router.state.$stateParams
   * @requires ui.router.router.$urlRouter
   *
   * @property {object} params A param object, e.g. {sectionId: section.id)}, that 
   * you&#x27;d like to test against the current active state.
   * @property {object} current A reference to the state&#x27;s config object. However 
   * you passed it in. Useful for accessing custom data.
   * @property {object} transition Currently pending transition. A promise that&#x27;ll 
   * resolve or reject.
   *
   * @description
   * &#x60;$state&#x60; service is responsible for representing states as well as transitioning
   * between them. It also provides interfaces to ask for current state or even states
   * you&#x27;re coming from.
   */
  this.$get = $get;
  $get.$inject = [&#x27;$rootScope&#x27;, &#x27;$q&#x27;, &#x27;$view&#x27;, &#x27;$injector&#x27;, &#x27;$resolve&#x27;, &#x27;$stateParams&#x27;, &#x27;$urlRouter&#x27;, &#x27;$location&#x27;, &#x27;$urlMatcherFactory&#x27;];
  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {

    var TransitionSuperseded = $q.reject(new Error(&#x27;transition superseded&#x27;));
    var TransitionPrevented = $q.reject(new Error(&#x27;transition prevented&#x27;));
    var TransitionAborted = $q.reject(new Error(&#x27;transition aborted&#x27;));
    var TransitionFailed = $q.reject(new Error(&#x27;transition failed&#x27;));

    // Handles the case where a state which is the target of a transition is not found, and the user
    // can optionally retry or defer the transition
    function handleRedirect(redirect, state, params, options) {
      /**
       * @ngdoc event
       * @name ui.router.state.$state#$stateNotFound
       * @eventOf ui.router.state.$state
       * @eventType broadcast on root scope
       * @description
       * Fired when a requested state **cannot be found** using the provided state name during transition.
       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by
       * lazy-loading the unfound state). A special &#x60;unfoundState&#x60; object is passed to the listener handler,
       * you can see its three properties in the example. You can use &#x60;event.preventDefault()&#x60; to abort the
       * transition and the promise returned from &#x60;go&#x60; will be rejected with a &#x60;&#x27;transition aborted&#x27;&#x60; value.
       *
       * @param {Object} event Event object.
       * @param {Object} unfoundState Unfound State information. Contains: &#x60;to, toParams, options&#x60; properties.
       * @param {State} fromState Current state object.
       * @param {Object} fromParams Current state params.
       *
       * @example
       *
       * &lt;pre&gt;
       * // somewhere, assume lazy.state has not been defined
       * $state.go(&quot;lazy.state&quot;, {a:1, b:2}, {inherit:false});
       *
       * // somewhere else
       * $scope.$on(&#x27;$stateNotFound&#x27;,
       * function(event, unfoundState, fromState, fromParams){
       *     console.log(unfoundState.to); // &quot;lazy.state&quot;
       *     console.log(unfoundState.toParams); // {a:1, b:2}
       *     console.log(unfoundState.options); // {inherit:false} + default options
       * })
       * &lt;/pre&gt;
       */
      var evt = $rootScope.$broadcast(&#x27;$stateNotFound&#x27;, redirect, state, params);

      if (evt.defaultPrevented) {
        $urlRouter.update();
        return TransitionAborted;
      }

      if (!evt.retry) {
        return null;
      }

      // Allow the handler to return a promise to defer state lookup retry
      if (options.$retry) {
        $urlRouter.update();
        return TransitionFailed;
      }
      var retryTransition = $state.transition = $q.when(evt.retry);

      retryTransition.then(function() {
        if (retryTransition !== $state.transition) return TransitionSuperseded;
        redirect.options.$retry = true;
        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
      }, function() {
        return TransitionAborted;
      });
      $urlRouter.update();

      return retryTransition;
    }

    root.locals = { resolve: null, globals: { $stateParams: {} } };

    $state = {
      params: {},
      current: root.self,
      $current: root,
      transition: null
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#reload
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method that force reloads the current state. All resolves are re-resolved,
     * controllers reinstantiated, and events re-fired.
     *
     * @example
     * &lt;pre&gt;
     * var app angular.module(&#x27;app&#x27;, [&#x27;ui.router&#x27;]);
     *
     * app.controller(&#x27;ctrl&#x27;, function ($scope, $state) {
     *   $scope.reload = function(){
     *     $state.reload();
     *   }
     * });
     * &lt;/pre&gt;
     *
     * &#x60;reload()&#x60; is just an alias for:
     * &lt;pre&gt;
     * $state.transitionTo($state.current, $stateParams, { 
     *   reload: true, inherit: false, notify: true
     * });
     * &lt;/pre&gt;
     *
     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.
     * @example
     * &lt;pre&gt;
     * //assuming app application consists of 3 states: &#x27;contacts&#x27;, &#x27;contacts.detail&#x27;, &#x27;contacts.detail.item&#x27; 
     * //and current state is &#x27;contacts.detail.item&#x27;
     * var app angular.module(&#x27;app&#x27;, [&#x27;ui.router&#x27;]);
     *
     * app.controller(&#x27;ctrl&#x27;, function ($scope, $state) {
     *   $scope.reload = function(){
     *     //will reload &#x27;contact.detail&#x27; and &#x27;contact.detail.item&#x27; states
     *     $state.reload(&#x27;contact.detail&#x27;);
     *   }
     * });
     * &lt;/pre&gt;
     *
     * &#x60;reload()&#x60; is just an alias for:
     * &lt;pre&gt;
     * $state.transitionTo($state.current, $stateParams, { 
     *   reload: true, inherit: false, notify: true
     * });
     * &lt;/pre&gt;

     * @returns {promise} A promise representing the state of the new transition. See
     * {@link ui.router.state.$state#methods_go $state.go}.
     */
    $state.reload = function reload(state) {
      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#go
     * @methodOf ui.router.state.$state
     *
     * @description
     * Convenience method for transitioning to a new state. &#x60;$state.go&#x60; calls 
     * &#x60;$state.transitionTo&#x60; internally but automatically sets options to 
     * &#x60;{ location: true, inherit: true, relative: $state.$current, notify: true }&#x60;. 
     * This allows you to easily use an absolute or relative to path and specify 
     * only the parameters you&#x27;d like to update (while letting unspecified parameters 
     * inherit from the currently active ancestor states).
     *
     * @example
     * &lt;pre&gt;
     * var app = angular.module(&#x27;app&#x27;, [&#x27;ui.router&#x27;]);
     *
     * app.controller(&#x27;ctrl&#x27;, function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.go(&#x27;contact.detail&#x27;);
     *   };
     * });
     * &lt;/pre&gt;
     * &lt;img src=&#x27;../ngdoc_assets/StateGoExamples.png&#x27;/&gt;
     *
     * @param {string} to Absolute state name or relative state path. Some examples:
     *
     * - &#x60;$state.go(&#x27;contact.detail&#x27;)&#x60; - will go to the &#x60;contact.detail&#x60; state
     * - &#x60;$state.go(&#x27;^&#x27;)&#x60; - will go to a parent state
     * - &#x60;$state.go(&#x27;^.sibling&#x27;)&#x60; - will go to a sibling state
     * - &#x60;$state.go(&#x27;.child.grandchild&#x27;)&#x60; - will go to grandchild state
     *
     * @param {object=} params A map of the parameters that will be sent to the state, 
     * will populate $stateParams. Any parameters that are not specified will be inherited from currently 
     * defined parameters. This allows, for example, going to a sibling state that shares parameters
     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.
     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child
     * will get you all current parameters, etc.
     * @param {object=} options Options object. The options are:
     *
     * - **&#x60;location&#x60;** - {boolean=true|string=} - If &#x60;true&#x60; will update the url in the location bar, if &#x60;false&#x60;
     *    will not. If string, must be &#x60;&quot;replace&quot;&#x60;, which will update url and also replace last history record.
     * - **&#x60;inherit&#x60;** - {boolean=true}, If &#x60;true&#x60; will inherit url parameters from current url.
     * - **&#x60;relative&#x60;** - {object=$state.$current}, When transitioning with relative path (e.g &#x27;^&#x27;), 
     *    defines which state to be relative from.
     * - **&#x60;notify&#x60;** - {boolean=true}, If &#x60;true&#x60; will broadcast $stateChangeStart and $stateChangeSuccess events.
     * - **&#x60;reload&#x60;** (v0.2.5) - {boolean=false}, If &#x60;true&#x60; will force transition even if the state or params 
     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you&#x27;d
     *    use this when you want to force a reload when *everything* is the same, including search params.
     *
     * @returns {promise} A promise representing the state of the new transition.
     *
     * Possible success values:
     *
     * - $state.current
     *
     * &lt;br/&gt;Possible rejection values:
     *
     * - &#x27;transition superseded&#x27; - when a newer transition has been started after this one
     * - &#x27;transition prevented&#x27; - when &#x60;event.preventDefault()&#x60; has been called in a &#x60;$stateChangeStart&#x60; listener
     * - &#x27;transition aborted&#x27; - when &#x60;event.preventDefault()&#x60; has been called in a &#x60;$stateNotFound&#x60; listener or
     *   when a &#x60;$stateNotFound&#x60; &#x60;event.retry&#x60; promise errors.
     * - &#x27;transition failed&#x27; - when a state has been unsuccessfully found after 2 tries.
     * - *resolve error* - when an error has occurred with a &#x60;resolve&#x60;
     *
     */
    $state.go = function go(to, params, options) {
      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#transitionTo
     * @methodOf ui.router.state.$state
     *
     * @description
     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}
     * uses &#x60;transitionTo&#x60; internally. &#x60;$state.go&#x60; is recommended in most situations.
     *
     * @example
     * &lt;pre&gt;
     * var app = angular.module(&#x27;app&#x27;, [&#x27;ui.router&#x27;]);
     *
     * app.controller(&#x27;ctrl&#x27;, function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.transitionTo(&#x27;contact.detail&#x27;);
     *   };
     * });
     * &lt;/pre&gt;
     *
     * @param {string} to State name.
     * @param {object=} toParams A map of the parameters that will be sent to the state,
     * will populate $stateParams.
     * @param {object=} options Options object. The options are:
     *
     * - **&#x60;location&#x60;** - {boolean=true|string=} - If &#x60;true&#x60; will update the url in the location bar, if &#x60;false&#x60;
     *    will not. If string, must be &#x60;&quot;replace&quot;&#x60;, which will update url and also replace last history record.
     * - **&#x60;inherit&#x60;** - {boolean=false}, If &#x60;true&#x60; will inherit url parameters from current url.
     * - **&#x60;relative&#x60;** - {object=}, When transitioning with relative path (e.g &#x27;^&#x27;), 
     *    defines which state to be relative from.
     * - **&#x60;notify&#x60;** - {boolean=true}, If &#x60;true&#x60; will broadcast $stateChangeStart and $stateChangeSuccess events.
     * - **&#x60;reload&#x60;** (v0.2.5) - {boolean=false|string=|object=}, If &#x60;true&#x60; will force transition even if the state or params 
     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you&#x27;d
     *    use this when you want to force a reload when *everything* is the same, including search params.
     *    if String, then will reload the state with the name given in reload, and any children.
     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.
     *
     * @returns {promise} A promise representing the state of the new transition. See
     * {@link ui.router.state.$state#methods_go $state.go}.
     */
    $state.transitionTo = function transitionTo(to, toParams, options) {
      toParams = toParams || {};
      options = extend({
        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false
      }, options || {});

      var from = $state.$current, fromParams = $state.params, fromPath = from.path;
      var evt, toState = findState(to, options.relative);

      // Store the hash param for later (since it will be stripped out by various methods)
      var hash = toParams[&#x27;#&#x27;];

      if (!isDefined(toState)) {
        var redirect = { to: to, toParams: toParams, options: options };
        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);

        if (redirectResult) {
          return redirectResult;
        }

        // Always retry once if the $stateNotFound was not prevented
        // (handles either redirect changed or state lazy-definition)
        to = redirect.to;
        toParams = redirect.toParams;
        options = redirect.options;
        toState = findState(to, options.relative);

        if (!isDefined(toState)) {
          if (!options.relative) throw new Error(&quot;No such state &#x27;&quot; + to + &quot;&#x27;&quot;);
          throw new Error(&quot;Could not resolve &#x27;&quot; + to + &quot;&#x27; from state &#x27;&quot; + options.relative + &quot;&#x27;&quot;);
        }
      }
      if (toState[abstractKey]) throw new Error(&quot;Cannot transition to abstract state &#x27;&quot; + to + &quot;&#x27;&quot;);
      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
      if (!toState.params.$$validates(toParams)) return TransitionFailed;

      toParams = toState.params.$$values(toParams);
      to = toState;

      var toPath = to.path;

      // Starting from the root of the path, keep all levels that haven&#x27;t changed
      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];

      if (!options.reload) {
        while (state &amp;&amp; state === fromPath[keep] &amp;&amp; state.ownParams.$$equals(toParams, fromParams)) {
          locals = toLocals[keep] = state.locals;
          keep++;
          state = toPath[keep];
        }
      } else if (isString(options.reload) || isObject(options.reload)) {
        if (isObject(options.reload) &amp;&amp; !options.reload.name) {
          throw new Error(&#x27;Invalid reload state object&#x27;);
        }
        
        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
        if (options.reload &amp;&amp; !reloadState) {
          throw new Error(&quot;No such reload state &#x27;&quot; + (isString(options.reload) ? options.reload : options.reload.name) + &quot;&#x27;&quot;);
        }

        while (state &amp;&amp; state === fromPath[keep] &amp;&amp; state !== reloadState) {
          locals = toLocals[keep] = state.locals;
          keep++;
          state = toPath[keep];
        }
      }

      // If we&#x27;re going to the same state and all locals are kept, we&#x27;ve got nothing to do.
      // But clear &#x27;transition&#x27;, as we still want to cancel any other pending transitions.
      // TODO: We may not want to bump &#x27;transition&#x27; if we&#x27;re called from a location change
      // that we&#x27;ve initiated ourselves, because we might accidentally abort a legitimate
      // transition initiated from code?
      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
        if (hash) toParams[&#x27;#&#x27;] = hash;
        $state.params = toParams;
        copy($state.params, $stateParams);
        if (options.location &amp;&amp; to.navigable &amp;&amp; to.navigable.url) {
          $urlRouter.push(to.navigable.url, toParams, {
            $$avoidResync: true, replace: options.location === &#x27;replace&#x27;
          });
          $urlRouter.update(true);
        }
        $state.transition = null;
        return $q.when($state.current);
      }

      // Filter parameters before we pass them to event handlers etc.
      toParams = filterByKeys(to.params.$$keys(), toParams || {});

      // Broadcast start event and cancel the transition if requested
      if (options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeStart
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when the state transition **begins**. You can use &#x60;event.preventDefault()&#x60;
         * to prevent the transition from happening and then the transition promise will be
         * rejected with a &#x60;&#x27;transition prevented&#x27;&#x60; value.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the &#x60;toState&#x60;.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the &#x60;fromState&#x60;.
         *
         * @example
         *
         * &lt;pre&gt;
         * $rootScope.$on(&#x27;$stateChangeStart&#x27;,
         * function(event, toState, toParams, fromState, fromParams){
         *     event.preventDefault();
         *     // transitionTo() promise will be rejected with
         *     // a &#x27;transition prevented&#x27; error
         * })
         * &lt;/pre&gt;
         */
        if ($rootScope.$broadcast(&#x27;$stateChangeStart&#x27;, to.self, toParams, from.self, fromParams).defaultPrevented) {
          $rootScope.$broadcast(&#x27;$stateChangeCancel&#x27;, to.self, toParams, from.self, fromParams);
          $urlRouter.update();
          return TransitionPrevented;
        }
      }

      // Resolve locals for the remaining states, but don&#x27;t update any global state just
      // yet -- if anything fails to resolve the current state needs to remain untouched.
      // We also set up an inheritance chain for the locals here. This allows the view directive
      // to quickly look up the correct definition for each view in the current state. Even
      // though we create the locals object itself outside resolveState(), it is initially
      // empty and gets filled asynchronously. We need to keep track of the promise for the
      // (fully resolved) current locals, and pass this down the chain.
      var resolved = $q.when(locals);

      for (var l = keep; l &lt; toPath.length; l++, state = toPath[l]) {
        locals = toLocals[l] = inherit(locals);
        resolved = resolveState(state, toParams, state === to, resolved, locals, options);
      }

      // Once everything is resolved, we are ready to perform the actual transition
      // and return a promise for the new state. We also keep track of what the
      // current promise is, so that we can detect overlapping transitions and
      // keep only the outcome of the last transition.
      var transition = $state.transition = resolved.then(function () {
        var l, entering, exiting;

        if ($state.transition !== transition) return TransitionSuperseded;

        // Exit &#x27;from&#x27; states not kept
        for (l = fromPath.length - 1; l &gt;= keep; l--) {
          exiting = fromPath[l];
          if (exiting.self.onExit) {
            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
          }
          exiting.locals = null;
        }

        // Enter &#x27;to&#x27; states not kept
        for (l = keep; l &lt; toPath.length; l++) {
          entering = toPath[l];
          entering.locals = toLocals[l];
          if (entering.self.onEnter) {
            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
          }
        }

        // Re-add the saved hash before we start returning things
        if (hash) toParams[&#x27;#&#x27;] = hash;

        // Run it again, to catch any transitions in callbacks
        if ($state.transition !== transition) return TransitionSuperseded;

        // Update globals in $state
        $state.$current = to;
        $state.current = to.self;
        $state.params = toParams;
        copy($state.params, $stateParams);
        $state.transition = null;

        if (options.location &amp;&amp; to.navigable) {
          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
            $$avoidResync: true, replace: options.location === &#x27;replace&#x27;
          });
        }

        if (options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeSuccess
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired once the state transition is **complete**.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the &#x60;toState&#x60;.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the &#x60;fromState&#x60;.
         */
          $rootScope.$broadcast(&#x27;$stateChangeSuccess&#x27;, to.self, toParams, from.self, fromParams);
        }
        $urlRouter.update(true);

        return $state.current;
      }, function (error) {
        if ($state.transition !== transition) return TransitionSuperseded;

        $state.transition = null;
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeError
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when an **error occurs** during transition. It&#x27;s important to note that if you
         * have any errors in your resolve functions (javascript errors, non-existent services, etc)
         * they will not throw traditionally. You must listen for this $stateChangeError event to
         * catch **ALL** errors.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the &#x60;toState&#x60;.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the &#x60;fromState&#x60;.
         * @param {Error} error The resolve error object.
         */
        evt = $rootScope.$broadcast(&#x27;$stateChangeError&#x27;, to.self, toParams, from.self, fromParams, error);

        if (!evt.defaultPrevented) {
            $urlRouter.update();
        }

        return $q.reject(error);
      });

      return transition;
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#is
     * @methodOf ui.router.state.$state
     *
     * @description
     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},
     * but only checks for the full state name. If params is supplied then it will be
     * tested for strict equality against the current active params object, so all params
     * must match with none missing and no extras.
     *
     * @example
     * &lt;pre&gt;
     * $state.$current.name = &#x27;contacts.details.item&#x27;;
     *
     * // absolute name
     * $state.is(&#x27;contact.details.item&#x27;); // returns true
     * $state.is(contactDetailItemStateObject); // returns true
     *
     * // relative name (. and ^), typically from a template
     * // E.g. from the &#x27;contacts.details&#x27; template
     * &lt;div ng-class=&quot;{highlighted: $state.is(&#x27;.item&#x27;)}&quot;&gt;Item&lt;/div&gt;
     * &lt;/pre&gt;
     *
     * @param {string|object} stateOrName The state name (absolute or relative) or state object you&#x27;d like to check.
     * @param {object=} params A param object, e.g. &#x60;{sectionId: section.id}&#x60;, that you&#x27;d like
     * to test against the current active state.
     * @param {object=} options An options object.  The options are:
     *
     * - **&#x60;relative&#x60;** - {string|object} -  If &#x60;stateOrName&#x60; is a relative state name and &#x60;options.relative&#x60; is set, .is will
     * test relative to &#x60;options.relative&#x60; state (or name).
     *
     * @returns {boolean} Returns true if it is the state.
     */
    $state.is = function is(stateOrName, params, options) {
      options = extend({ relative: $state.$current }, options || {});
      var state = findState(stateOrName, options.relative);

      if (!isDefined(state)) { return undefined; }
      if ($state.$current !== state) { return false; }
      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#includes
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method to determine if the current active state is equal to or is the child of the
     * state stateName. If any params are passed then they will be tested for a match as well.
     * Not all the parameters need to be passed, just the ones you&#x27;d like to test for equality.
     *
     * @example
     * Partial and relative names
     * &lt;pre&gt;
     * $state.$current.name = &#x27;contacts.details.item&#x27;;
     *
     * // Using partial names
     * $state.includes(&quot;contacts&quot;); // returns true
     * $state.includes(&quot;contacts.details&quot;); // returns true
     * $state.includes(&quot;contacts.details.item&quot;); // returns true
     * $state.includes(&quot;contacts.list&quot;); // returns false
     * $state.includes(&quot;about&quot;); // returns false
     *
     * // Using relative names (. and ^), typically from a template
     * // E.g. from the &#x27;contacts.details&#x27; template
     * &lt;div ng-class=&quot;{highlighted: $state.includes(&#x27;.item&#x27;)}&quot;&gt;Item&lt;/div&gt;
     * &lt;/pre&gt;
     *
     * Basic globbing patterns
     * &lt;pre&gt;
     * $state.$current.name = &#x27;contacts.details.item.url&#x27;;
     *
     * $state.includes(&quot;*.details.*.*&quot;); // returns true
     * $state.includes(&quot;*.details.**&quot;); // returns true
     * $state.includes(&quot;**.item.**&quot;); // returns true
     * $state.includes(&quot;*.details.item.url&quot;); // returns true
     * $state.includes(&quot;*.details.*.url&quot;); // returns true
     * $state.includes(&quot;*.details.*&quot;); // returns false
     * $state.includes(&quot;item.**&quot;); // returns false
     * &lt;/pre&gt;
     *
     * @param {string} stateOrName A partial name, relative name, or glob pattern
     * to be searched for within the current state name.
     * @param {object=} params A param object, e.g. &#x60;{sectionId: section.id}&#x60;,
     * that you&#x27;d like to test against the current active state.
     * @param {object=} options An options object.  The options are:
     *
     * - **&#x60;relative&#x60;** - {string|object=} -  If &#x60;stateOrName&#x60; is a relative state reference and &#x60;options.relative&#x60; is set,
     * .includes will test relative to &#x60;options.relative&#x60; state (or name).
     *
     * @returns {boolean} Returns true if it does include the state
     */
    $state.includes = function includes(stateOrName, params, options) {
      options = extend({ relative: $state.$current }, options || {});
      if (isString(stateOrName) &amp;&amp; isGlob(stateOrName)) {
        if (!doesStateMatchGlob(stateOrName)) {
          return false;
        }
        stateOrName = $state.$current.name;
      }

      var state = findState(stateOrName, options.relative);
      if (!isDefined(state)) { return undefined; }
      if (!isDefined($state.$current.includes[state.name])) { return false; }
      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
    };


    /**
     * @ngdoc function
     * @name ui.router.state.$state#href
     * @methodOf ui.router.state.$state
     *
     * @description
     * A url generation method that returns the compiled url for the given state populated with the given params.
     *
     * @example
     * &lt;pre&gt;
     * expect($state.href(&quot;about.person&quot;, { person: &quot;bob&quot; })).toEqual(&quot;/about/bob&quot;);
     * &lt;/pre&gt;
     *
     * @param {string|object} stateOrName The state name or state object you&#x27;d like to generate a url from.
     * @param {object=} params An object of parameter values to fill the state&#x27;s required parameters.
     * @param {object=} options Options object. The options are:
     *
     * - **&#x60;lossy&#x60;** - {boolean=true} -  If true, and if there is no url associated with the state provided in the
     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka
     *    ancestor with a valid url).
     * - **&#x60;inherit&#x60;** - {boolean=true}, If &#x60;true&#x60; will inherit url parameters from current url.
     * - **&#x60;relative&#x60;** - {object=$state.$current}, When transitioning with relative path (e.g &#x27;^&#x27;), 
     *    defines which state to be relative from.
     * - **&#x60;absolute&#x60;** - {boolean=false},  If true will generate an absolute url, e.g. &quot;http://www.example.com/fullurl&quot;.
     * 
     * @returns {string} compiled state url
     */
    $state.href = function href(stateOrName, params, options) {
      options = extend({
        lossy:    true,
        inherit:  true,
        absolute: false,
        relative: $state.$current
      }, options || {});

      var state = findState(stateOrName, options.relative);

      if (!isDefined(state)) return null;
      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);
      
      var nav = (state &amp;&amp; options.lossy) ? state.navigable : state;

      if (!nav || nav.url === undefined || nav.url === null) {
        return null;
      }
      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat(&#x27;#&#x27;), params || {}), {
        absolute: options.absolute
      });
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#get
     * @methodOf ui.router.state.$state
     *
     * @description
     * Returns the state configuration object for any specific state or all states.
     *
     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for
     * the requested state. If not provided, returns an array of ALL state configs.
     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.
     * @returns {Object|Array} State configuration object or array of all objects.
     */
    $state.get = function (stateOrName, context) {
      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });
      var state = findState(stateOrName, context || $state.$current);
      return (state &amp;&amp; state.self) ? state.self : null;
    };

    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
      // Make a restricted $stateParams with only the parameters that apply to this state if
      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,
      // we also need $stateParams to be available for any $injector calls we make during the
      // dependency resolution process.
      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
      var locals = { $stateParams: $stateParams };

      // Resolve &#x27;global&#x27; dependencies for the state, i.e. those not specific to a view.
      // We&#x27;re also including $stateParams in this; that way the parameters are restricted
      // to the set that should be visible to the state, and are independent of when we update
      // the global $state and $stateParams values.
      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
      var promises = [dst.resolve.then(function (globals) {
        dst.globals = globals;
      })];
      if (inherited) promises.push(inherited);

      function resolveViews() {
        var viewsPromises = [];

        // Resolve template and dependencies for all views.
        forEach(state.views, function (view, name) {
          var injectables = (view.resolve &amp;&amp; view.resolve !== state.resolve ? view.resolve : {});
          injectables.$template = [ function () {
            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || &#x27;&#x27;;
          }];

          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {
            // References to the controller (only instantiated at link time)
            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
              var injectLocals = angular.extend({}, injectables, dst.globals);
              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
            } else {
              result.$$controller = view.controller;
            }
            // Provide access to the state itself for internal use
            result.$$state = state;
            result.$$controllerAs = view.controllerAs;
            dst[name] = result;
          }));
        });

        return $q.all(viewsPromises).then(function(){
          return dst.globals;
        });
      }

      // Wait for all the promises and then return the activation object
      return $q.all(promises).then(resolveViews).then(function (values) {
        return dst;
      });
    }

    return $state;
  }

  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
    // Return true if there are no differences in non-search (path/object) params, false if there are differences
    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
      // Identify whether all the parameters that differ between &#x60;fromParams&#x60; and &#x60;toParams&#x60; were search params.
      function notSearchParam(key) {
        return fromAndToState.params[key].location != &quot;search&quot;;
      }
      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
      return nonQueryParamSet.$$equals(fromParams, toParams);
    }

    // If reload was not explicitly requested
    // and we&#x27;re transitioning to the same state we&#x27;re already in
    // and    the locals didn&#x27;t change
    //     or they changed in a way that doesn&#x27;t merit reloading
    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)
    // Then return true.
    if (!options.reload &amp;&amp; to === from &amp;&amp;
      (locals === from.locals || (to.self.reloadOnSearch === false &amp;&amp; nonSearchParamsEqual(from, fromParams, toParams)))) {
      return true;
    }
  }
}

angular.module(&#x27;ui.router.state&#x27;)
  .value(&#x27;$stateParams&#x27;, {})
  .provider(&#x27;$state&#x27;, $StateProvider);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
